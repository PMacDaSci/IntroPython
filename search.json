[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "This workshop is designed to give beginners a solid foundation in Python programming, with a specific focus on applications in cancer biology. Participants will gain a thorough understanding of essential programming concepts through a blend of theoretical lessons, hands-on coding exercises, and practical applications.\nThe workshop will cover essential programming concepts and gradually introduce more advanced topics, with a focus on using the Pandas library for efficient data handling and analysis and matplotlib library for data visualization. By the end of the workshop, attendees will be equipped with the skills to enhance the reproducibility and efficiency of scientific research through powerful data analysis tools and effective visualization techniques."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Introduction",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nParticipants will gain the following skills:\n\nProficiency in using Python for data analysis.\nBasic Python programming skills.\nReading, tidying, and joining datasets using pandas library.\nData manipulation and transformation using pandas library.\nCreating various types of plots using matplotlib library."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore starting this course you will need to ensure that your computer is set up with the required software. If you have any difficulty installing any of this software then please contact one of the trainers for help.\n\nStep 1: Installing Python\nThere are multiple ways you can use Python at Peter Mac. The easiest and most convenient way is to install Python on your own computer. However, if you prefer to avoid the installation process or need additional computational capabilities the alternative option is to use the cluster.\n\nInstall Python on your own computer\nFor new users, we recommend installing Anaconda. Anaconda conveniently installs Python, the Jupyter Notebook, and other commonly used packages.\n\n\nWindows\n\nIf you have admin rights, follow Anaconda Navigator Installation. Otherwise, contact the IT Support.\n\n\n\nmacOS\n\nInstall the Anaconda Navigator from the PeterMac Self-Service → Research Applications tab or from the Anaconda Navigator Installation.\n\n\n\nLinux\n\nInstall the Anaconda Navigator from here.\n\n\nIf you are using Anaconda/Conda on your laptop/desktop on the Peter Mac network you may need to provide proxy settings by adding the following proxy servers as shown here\nTo update the .condarc file follow the quick start guide.\n\nIf you are having trouble opening the Anaconda Navigator please follow their troubleshooting page.\nOnce installed, open the anaconda-navigator directly or type the following command in the terminal to open it.\n\nanaconda-navigator\n\n\n\n\nFigure 1: Anaconda Navigator\n\n\nUseful links:\n\nGetting started with Navigator\nHow to create a Python environment?\nCreating and managing Python environments\nUsing multiple versions of Python with Navigator\nInstalling and managing Python packages\nHow to install and run Pandas from Anaconda Navigator?\nHow to use special characters in username/password for HTTP proxy?\n\n\n\nUse Python on the cluster?\nFollow the quick start guide on this page.\n\n\n\nStep 2: Installing Integrated Development Environment (IDE)\nOnce Python is installed, the next step is to install a preferred Integrated Development Environment (IDE) to start coding with Python. If you are a new user, we suggest using the Jupyter Notebook. Alternatively, if you are accustomed to using R Studio, it can also serve as a platform for Python coding.\n\nInstall Jupyter Notebook on your own computer\n\nOpen Anaconda Navigator and click install Jupyter Notebook.\nLaunch the Jupyter Notebook directly from the Anaconda Navigator or start the notebook server from the command line by typing the following command.\n\n\njupyter notebook \n\n\nYou should see the notebook home page open in your web browser.\n\n\n\n\nFigure 2: Jupyter Notebook\n\n\n\nTo install Jupyter Notebook, see Installing Jupyter Notebook.\n\nUseful links:\n\nJupyter Notebook Documentation\nHow to use Jupyter Notebooks - DataCamp\nJupyter Notebook: An Introduction\n\n\n\n\nUse Jupyter Notebook on Open OnDemand\nFollow the guide on this page.\nUseful links:\n\nUsing Jupyter on the cluster\nHow to login and use Ope OnDemand\n\n\n\nUse R Studio for Python coding\nThe RStudio IDE is a free and open-source IDE for Python, as well as R. You can write scripts, import modules, and interactively use Python within the RStudio IDE. Whether your intention is to seamlessly combine R and Python or solely concentrate on Python programming, there are several ways you can advance your coding:\n\nRun Python Scripts in the RStudio IDE\nUse R and Python in a single project with the reticulate Package\nUse your Python editor of choice within RStudio tools\n\n\n\nStep 3: Installing a Python library\nIf you are currently using Python using conda (or Anaconda) or if you are using the cluster, a Python library can be installed with Anaconda or Miniconda. For example, to install the pandas and matplotlib libraries of Python use the following command on the terminal.\n\nconda install conda-forge::pandas \nconda install conda-forge::matplotlib \n\nIf you installed Python using Pip, then a Python library can be installed via pip from Python Package Index (PyPI). To install the pandas library of Python use the following command on the terminal.\n\npip install pandas \npip install matplotlib \n\nIf Anaconda Navigator is installed and you prefer to use the Navigator instead of typing commands on a terminal refer to Installing and managing Python packages.\nUseful links:\n\nInstalling conda packages\nInstalling and managing Python packages\nPython Package Index (PyPI)"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Introduction",
    "section": "Data",
    "text": "Data\nThe Metabric study characterized the genomic mutations and gene expression profiles for 2509 primary breast tumours. In addition to the gene expression data generated using microarrays, genome-wide copy number profiles were obtained using SNP microarrays. Targeted sequencing was performed for 2509 primary breast tumours, along with 548 matched normals, using a panel of 173 of the most frequently mutated breast cancer genes as part of the Metabric study.\nRefrences:\n\nCurtis et al., Nature 486:346-52, 2012\nPereira et al., Nature Communications 7:11479, 2016\n\nBoth the clinical data and the gene expression values were downloaded from cBioPortal.\nWe excluded observations for patient tumor samples lacking expression data, resulting in a data set with fewer rows."
  },
  {
    "objectID": "index.html#credits-and-acknowledgement",
    "href": "index.html#credits-and-acknowledgement",
    "title": "Introduction",
    "section": "Credits and Acknowledgement",
    "text": "Credits and Acknowledgement\nThese content were adapted from the following course materials:\n\nR for Data Science book\nOHI Data Science Training\nData Carpentry\nWEHI tidyr coursebook by Brendan R. E. Ansell\ncontent developed by Maria Doyle."
  },
  {
    "objectID": "vignettes/1_Introduction.html",
    "href": "vignettes/1_Introduction.html",
    "title": "Basics of Python Programming Language",
    "section": "",
    "text": "Python is a dynamic, interpreted general purpose programming language initially created by Guido van Rossum in 1991.\nSupports several popular programming paradigms:\n\nprocedural\nobject-oriented\nfunctional\n\nPython is widely used in bioinformatics and scientific computing, as well as many other fields and in industry.\nSpecifically designed to make programs readable and easy to develop.\nVersatile and easy-to-use language.\nPython is available on all popular operating systems"
  },
  {
    "objectID": "vignettes/1_Introduction.html#what-is-python",
    "href": "vignettes/1_Introduction.html#what-is-python",
    "title": "Basics of Python Programming Language",
    "section": "",
    "text": "Python is a dynamic, interpreted general purpose programming language initially created by Guido van Rossum in 1991.\nSupports several popular programming paradigms:\n\nprocedural\nobject-oriented\nfunctional\n\nPython is widely used in bioinformatics and scientific computing, as well as many other fields and in industry.\nSpecifically designed to make programs readable and easy to develop.\nVersatile and easy-to-use language.\nPython is available on all popular operating systems"
  },
  {
    "objectID": "vignettes/1_Introduction.html#why-learn-python",
    "href": "vignettes/1_Introduction.html#why-learn-python",
    "title": "Basics of Python Programming Language",
    "section": "Why learn Python?",
    "text": "Why learn Python?\n\nR and Python are the two most popular programming languages used by data analysts and data scientists. Both are free and open source.\nPython is a general-purpose programming language, while R is a statistical programming language.\nGoogle Trend Search Index for R (blue) versus Python (red) over the last 10 years:"
  },
  {
    "objectID": "vignettes/1_Introduction.html#python-programming-language",
    "href": "vignettes/1_Introduction.html#python-programming-language",
    "title": "Basics of Python Programming Language",
    "section": "Python Programming Language",
    "text": "Python Programming Language\n\nStandard library provides built-in support for several common tasks:\n\nnumerical & mathematical functions\ninteracting with files and the operating system etc.\n\nHas a rich library:\n\nPandas - Data Manipulation and Analysis\n\nBioPython - For Bioinformatics\nNumPy - Multi-dimensional arrays/matrices along with high-level mathematical functions\nMatplotlib - For Plots\nTensorFlow - Machine Learning and AI"
  },
  {
    "objectID": "vignettes/1_Introduction.html#how-to-use-python",
    "href": "vignettes/1_Introduction.html#how-to-use-python",
    "title": "Basics of Python Programming Language",
    "section": "How to use Python?",
    "text": "How to use Python?\n\nInteractive Mode\n\nFirst invoke the Python interpreter and then work with it interactively.\nGive the interpreter Python commands, one at a time.\nTo start the Python interpreter in interactive mode, type the command python on the command-line (shell prompt), as shown below. \n\n\n\nScripting Mode\n\nScripting mode is also called the normal mode (programming mode)\nNon-interactive\nProvide the Python interpreter a text file containing a Python program (script) as input, on the command-line, as follows: \n\n\n\nJupyter Notebook\n\nA web application that allows creating and sharing documents that contain live code, equations, visualizations and explanatory text.\nProvides a rich architecture for interactive data science and scientific computing with:\n\nOver 40 programming languages such as Python, R, Julia and Scala.\nA browser-based notebook with support for code, rich text, math expressions, plots and other rich media.\nSupport for interactive data visualization.\nEasy to use tools for parallel computing.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn this course, we will use Jupyter Notebook (or JupyterLab—the more powerful and extensible evolution of Jupyter Notebook—for all Python coding exercises). Feel free to choose either Jupyter Notebook or JupyterLab based on your preference, as both are widely supported and have similar functionality for the purposes of this course.\n\n\n\n\nAny IDE of your choice\n\n\n\nGoogle search top 10 results: Integrated development environment Software / python"
  },
  {
    "objectID": "vignettes/1_Introduction.html#a-look-around-jupyter-notebook",
    "href": "vignettes/1_Introduction.html#a-look-around-jupyter-notebook",
    "title": "Basics of Python Programming Language",
    "section": "A look around Jupyter Notebook",
    "text": "A look around Jupyter Notebook\n\nOpen Jupyter Notebook and create a new notebook as shown below.\n\n\n\n\n\n\n\n\n\nJuptyer has two modes: edit mode (blue cell border) and command mode (grey) cell border).\n\nTo enter edit mode, press Enter or click into a cell. In edit mode, most of the keyboard is dedicated to typing into the cell’s editor. Thus, in edit mode there are relatively few shortcuts.\n\nTo enter command mode, press Esc. In command mode, the entire keyboard is available for shortcuts, so there are many more.\n\n\nTo enter different types of content—such as Markdown, raw text, or Python code, you need to select the appropriate cell type. You can do this by using the drop-down menu in the toolbar at the top of the Jupyter Notebook interface.\n\nCode cells allow you to write and execute Python code.\nMarkdown cells are used to format text with headings, lists, links, and other rich text features.\nRaw cells allow you to input unformatted text that will not be executed or rendered.\n\n\n\n\nShortcuts to execute cells in both modes:\n\nShift + Enter run the current cell \nCtrl + Enter (Mac: Cmd + Enter) run selected cells\nAlt + Enter (Mac: Option + Enter) run the current cell, insert below\nCtrl + S (Mac: Cmd + S) save and checkpoint \n\nSome useful shortcuts, in command mode:\n\nUp select cell above\nDown select cell below\nShift + Up extend selected cells above\nShift + Down extend selected cells below\nA insert cell above \nB insert cell below \nD + D (press the key twice) delete selected cells \n\nThe Help-&gt;Keyboard Shortcuts dialog lists the available shortcuts (or type h in Command mode).\n\n\nTo get started, open Jupyter Notebook and navigate to the IntroPython folder, which was shared with you. Once inside, open the notebook titled IntroPython-Day1.ipynb. This notebook contains the materials and exercises for Day 1 of the course."
  },
  {
    "objectID": "vignettes/1_Introduction.html#comments",
    "href": "vignettes/1_Introduction.html#comments",
    "title": "Basics of Python Programming Language",
    "section": "Comments",
    "text": "Comments\nWhen writing code it is very handy to make notes to yourself about what the code is doing. In Python, any text that appears after the hash symbol ‘#’ is called a ‘comment’. Python interpreter can’t see this text, and won’t try to run it as commands. Comments are useful for reminding your future self what you were aiming to do with a particular line of code, and what was or wasn’t working.\n\n# This is a comment"
  },
  {
    "objectID": "vignettes/1_Introduction.html#help",
    "href": "vignettes/1_Introduction.html#help",
    "title": "Basics of Python Programming Language",
    "section": "Help",
    "text": "Help\nThe Python help() function invokes the interactive built-in help system. If the argument is a string, then the string is treated as the name of a module, function, class, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is displayed.\nIt’s recommended to try it in your interpreter when you need help to write Python program and use Python modules.\nThe following displays the help on the builtin print function.\n\nhelp('print')\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n    \n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\nThe following displays the help page on the math module (or library).\n\n\nhelp('math')\n\nHelp on module math:\n\nNAME\n    math\n\nDESCRIPTION\n    This module provides access to the mathematical functions\n    defined by the C standard.\n\nFUNCTIONS\n    acos(x, /)\n        Return the arc cosine (measured in radians) of x.\n        \n        The result is between 0 and pi.\n    \n    acosh(x, /)\n        Return the inverse hyperbolic cosine of x.\n    \n    asin(x, /)\n        Return the arc sine (measured in radians) of x.\n        \n        The result is between -pi/2 and pi/2.\n    \n    asinh(x, /)\n        Return the inverse hyperbolic sine of x.\n    \n    atan(x, /)\n        Return the arc tangent (measured in radians) of x.\n        \n        The result is between -pi/2 and pi/2.\n    \n    atan2(y, x, /)\n        Return the arc tangent (measured in radians) of y/x.\n        \n        Unlike atan(y/x), the signs of both x and y are considered.\n    \n    atanh(x, /)\n        Return the inverse hyperbolic tangent of x.\n    \n    cbrt(x, /)\n        Return the cube root of x.\n    \n    ceil(x, /)\n        Return the ceiling of x as an Integral.\n        \n        This is the smallest integer &gt;= x.\n    \n    comb(n, k, /)\n        Number of ways to choose k items from n items without repetition and without order.\n        \n        Evaluates to n! / (k! * (n - k)!) when k &lt;= n and evaluates\n        to zero when k &gt; n.\n        \n        Also called the binomial coefficient because it is equivalent\n        to the coefficient of k-th term in polynomial expansion of the\n        expression (1 + x)**n.\n        \n        Raises TypeError if either of the arguments are not integers.\n        Raises ValueError if either of the arguments are negative.\n    \n    copysign(x, y, /)\n        Return a float with the magnitude (absolute value) of x but the sign of y.\n        \n        On platforms that support signed zeros, copysign(1.0, -0.0)\n        returns -1.0.\n    \n    cos(x, /)\n        Return the cosine of x (measured in radians).\n    \n    cosh(x, /)\n        Return the hyperbolic cosine of x.\n    \n    degrees(x, /)\n        Convert angle x from radians to degrees.\n    \n    dist(p, q, /)\n        Return the Euclidean distance between two points p and q.\n        \n        The points should be specified as sequences (or iterables) of\n        coordinates.  Both inputs must have the same dimension.\n        \n        Roughly equivalent to:\n            sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))\n    \n    erf(x, /)\n        Error function at x.\n    \n    erfc(x, /)\n        Complementary error function at x.\n    \n    exp(x, /)\n        Return e raised to the power of x.\n    \n    exp2(x, /)\n        Return 2 raised to the power of x.\n    \n    expm1(x, /)\n        Return exp(x)-1.\n        \n        This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\n    \n    fabs(x, /)\n        Return the absolute value of the float x.\n    \n    factorial(n, /)\n        Find n!.\n        \n        Raise a ValueError if x is negative or non-integral.\n    \n    floor(x, /)\n        Return the floor of x as an Integral.\n        \n        This is the largest integer &lt;= x.\n    \n    fmod(x, y, /)\n        Return fmod(x, y), according to platform C.\n        \n        x % y may differ.\n    \n    frexp(x, /)\n        Return the mantissa and exponent of x, as pair (m, e).\n        \n        m is a float and e is an int, such that x = m * 2.**e.\n        If x is 0, m and e are both 0.  Else 0.5 &lt;= abs(m) &lt; 1.0.\n    \n    fsum(seq, /)\n        Return an accurate floating point sum of values in the iterable seq.\n        \n        Assumes IEEE-754 floating point arithmetic.\n    \n    gamma(x, /)\n        Gamma function at x.\n    \n    gcd(*integers)\n        Greatest Common Divisor.\n    \n    hypot(...)\n        hypot(*coordinates) -&gt; value\n        \n        Multidimensional Euclidean distance from the origin to a point.\n        \n        Roughly equivalent to:\n            sqrt(sum(x**2 for x in coordinates))\n        \n        For a two dimensional point (x, y), gives the hypotenuse\n        using the Pythagorean theorem:  sqrt(x*x + y*y).\n        \n        For example, the hypotenuse of a 3/4/5 right triangle is:\n        \n            &gt;&gt;&gt; hypot(3.0, 4.0)\n            5.0\n    \n    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)\n        Determine whether two floating point numbers are close in value.\n        \n          rel_tol\n            maximum difference for being considered \"close\", relative to the\n            magnitude of the input values\n          abs_tol\n            maximum difference for being considered \"close\", regardless of the\n            magnitude of the input values\n        \n        Return True if a is close in value to b, and False otherwise.\n        \n        For the values to be considered close, the difference between them\n        must be smaller than at least one of the tolerances.\n        \n        -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\n        is, NaN is not close to anything, even itself.  inf and -inf are\n        only close to themselves.\n    \n    isfinite(x, /)\n        Return True if x is neither an infinity nor a NaN, and False otherwise.\n    \n    isinf(x, /)\n        Return True if x is a positive or negative infinity, and False otherwise.\n    \n    isnan(x, /)\n        Return True if x is a NaN (not a number), and False otherwise.\n    \n    isqrt(n, /)\n        Return the integer part of the square root of the input.\n    \n    lcm(*integers)\n        Least Common Multiple.\n    \n    ldexp(x, i, /)\n        Return x * (2**i).\n        \n        This is essentially the inverse of frexp().\n    \n    lgamma(x, /)\n        Natural logarithm of absolute value of Gamma function at x.\n    \n    log(...)\n        log(x, [base=math.e])\n        Return the logarithm of x to the given base.\n        \n        If the base not specified, returns the natural logarithm (base e) of x.\n    \n    log10(x, /)\n        Return the base 10 logarithm of x.\n    \n    log1p(x, /)\n        Return the natural logarithm of 1+x (base e).\n        \n        The result is computed in a way which is accurate for x near zero.\n    \n    log2(x, /)\n        Return the base 2 logarithm of x.\n    \n    modf(x, /)\n        Return the fractional and integer parts of x.\n        \n        Both results carry the sign of x and are floats.\n    \n    nextafter(x, y, /)\n        Return the next floating-point value after x towards y.\n    \n    perm(n, k=None, /)\n        Number of ways to choose k items from n items without repetition and with order.\n        \n        Evaluates to n! / (n - k)! when k &lt;= n and evaluates\n        to zero when k &gt; n.\n        \n        If k is not specified or is None, then k defaults to n\n        and the function returns n!.\n        \n        Raises TypeError if either of the arguments are not integers.\n        Raises ValueError if either of the arguments are negative.\n    \n    pow(x, y, /)\n        Return x**y (x to the power of y).\n    \n    prod(iterable, /, *, start=1)\n        Calculate the product of all the elements in the input iterable.\n        \n        The default start value for the product is 1.\n        \n        When the iterable is empty, return the start value.  This function is\n        intended specifically for use with numeric values and may reject\n        non-numeric types.\n    \n    radians(x, /)\n        Convert angle x from degrees to radians.\n    \n    remainder(x, y, /)\n        Difference between x and the closest integer multiple of y.\n        \n        Return x - n*y where n*y is the closest integer multiple of y.\n        In the case where x is exactly halfway between two multiples of\n        y, the nearest even value of n is used. The result is always exact.\n    \n    sin(x, /)\n        Return the sine of x (measured in radians).\n    \n    sinh(x, /)\n        Return the hyperbolic sine of x.\n    \n    sqrt(x, /)\n        Return the square root of x.\n    \n    tan(x, /)\n        Return the tangent of x (measured in radians).\n    \n    tanh(x, /)\n        Return the hyperbolic tangent of x.\n    \n    trunc(x, /)\n        Truncates the Real x to the nearest Integral toward 0.\n        \n        Uses the __trunc__ magic method.\n    \n    ulp(x, /)\n        Return the value of the least significant bit of the float x.\n\nDATA\n    e = 2.718281828459045\n    inf = inf\n    nan = nan\n    pi = 3.141592653589793\n    tau = 6.283185307179586\n\nFILE\n    /opt/homebrew/Cellar/python@3.11/3.11.5/Frameworks/Python.framework/Versions/3.11/lib/python3.11/lib-dynload/math.cpython-311-darwin.so\n\n\n\n\n\nThe help function can also be used on built-in or user-defined classes.\n\n\nhelp('int')\n\nHelp on class int in module builtins:\n\nclass int(object)\n |  int([x]) -&gt; integer\n |  int(x, base=10) -&gt; integer\n |  \n |  Convert a number or string to an integer, or return 0 if no arguments\n |  are given.  If x is a number, return x.__int__().  For floating point\n |  numbers, this truncates towards zero.\n |  \n |  If x is not a number or if base is given, then x must be a string,\n |  bytes, or bytearray instance representing an integer literal in the\n |  given base.  The literal can be preceded by '+' or '-' and be surrounded\n |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n |  Base 0 means to interpret the base from the string as an integer literal.\n |  &gt;&gt;&gt; int('0b100', base=0)\n |  4\n |  \n |  Built-in subclasses:\n |      bool\n |  \n |  Methods defined here:\n |  \n |  __abs__(self, /)\n |      abs(self)\n |  \n |  __add__(self, value, /)\n |      Return self+value.\n |  \n |  __and__(self, value, /)\n |      Return self&value.\n |  \n |  __bool__(self, /)\n |      True if self else False\n |  \n |  __ceil__(...)\n |      Ceiling of an Integral returns itself.\n |  \n |  __divmod__(self, value, /)\n |      Return divmod(self, value).\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __float__(self, /)\n |      float(self)\n |  \n |  __floor__(...)\n |      Flooring an Integral returns itself.\n |  \n |  __floordiv__(self, value, /)\n |      Return self//value.\n |  \n |  __format__(self, format_spec, /)\n |      Default object formatter.\n |  \n |  __ge__(self, value, /)\n |      Return self&gt;=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getnewargs__(self, /)\n |  \n |  __gt__(self, value, /)\n |      Return self&gt;value.\n |  \n |  __hash__(self, /)\n |      Return hash(self).\n |  \n |  __index__(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |  \n |  __int__(self, /)\n |      int(self)\n |  \n |  __invert__(self, /)\n |      ~self\n |  \n |  __le__(self, value, /)\n |      Return self&lt;=value.\n |  \n |  __lshift__(self, value, /)\n |      Return self&lt;&lt;value.\n |  \n |  __lt__(self, value, /)\n |      Return self&lt;value.\n |  \n |  __mod__(self, value, /)\n |      Return self%value.\n |  \n |  __mul__(self, value, /)\n |      Return self*value.\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __neg__(self, /)\n |      -self\n |  \n |  __or__(self, value, /)\n |      Return self|value.\n |  \n |  __pos__(self, /)\n |      +self\n |  \n |  __pow__(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |  \n |  __radd__(self, value, /)\n |      Return value+self.\n |  \n |  __rand__(self, value, /)\n |      Return value&self.\n |  \n |  __rdivmod__(self, value, /)\n |      Return divmod(value, self).\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __rfloordiv__(self, value, /)\n |      Return value//self.\n |  \n |  __rlshift__(self, value, /)\n |      Return value&lt;&lt;self.\n |  \n |  __rmod__(self, value, /)\n |      Return value%self.\n |  \n |  __rmul__(self, value, /)\n |      Return value*self.\n |  \n |  __ror__(self, value, /)\n |      Return value|self.\n |  \n |  __round__(...)\n |      Rounding an Integral returns itself.\n |      \n |      Rounding with an ndigits argument also returns an integer.\n |  \n |  __rpow__(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |  \n |  __rrshift__(self, value, /)\n |      Return value&gt;&gt;self.\n |  \n |  __rshift__(self, value, /)\n |      Return self&gt;&gt;value.\n |  \n |  __rsub__(self, value, /)\n |      Return value-self.\n |  \n |  __rtruediv__(self, value, /)\n |      Return value/self.\n |  \n |  __rxor__(self, value, /)\n |      Return value^self.\n |  \n |  __sizeof__(self, /)\n |      Returns size in memory, in bytes.\n |  \n |  __sub__(self, value, /)\n |      Return self-value.\n |  \n |  __truediv__(self, value, /)\n |      Return self/value.\n |  \n |  __trunc__(...)\n |      Truncating an Integral returns itself.\n |  \n |  __xor__(self, value, /)\n |      Return self^value.\n |  \n |  as_integer_ratio(self, /)\n |      Return integer ratio.\n |      \n |      Return a pair of integers, whose ratio is exactly equal to the original int\n |      and with a positive denominator.\n |      \n |      &gt;&gt;&gt; (10).as_integer_ratio()\n |      (10, 1)\n |      &gt;&gt;&gt; (-10).as_integer_ratio()\n |      (-10, 1)\n |      &gt;&gt;&gt; (0).as_integer_ratio()\n |      (0, 1)\n |  \n |  bit_count(self, /)\n |      Number of ones in the binary representation of the absolute value of self.\n |      \n |      Also known as the population count.\n |      \n |      &gt;&gt;&gt; bin(13)\n |      '0b1101'\n |      &gt;&gt;&gt; (13).bit_count()\n |      3\n |  \n |  bit_length(self, /)\n |      Number of bits necessary to represent self in binary.\n |      \n |      &gt;&gt;&gt; bin(37)\n |      '0b100101'\n |      &gt;&gt;&gt; (37).bit_length()\n |      6\n |  \n |  conjugate(...)\n |      Returns self, the complex conjugate of any int.\n |  \n |  to_bytes(self, /, length=1, byteorder='big', *, signed=False)\n |      Return an array of bytes representing an integer.\n |      \n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.  Default\n |        is length 1.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.  Default is to use 'big'.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  from_bytes(bytes, byteorder='big', *, signed=False) from builtins.type\n |      Return the integer represented by the given array of bytes.\n |      \n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.  Default is to use 'big'.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  denominator\n |      the denominator of a rational number in lowest terms\n |  \n |  imag\n |      the imaginary part of a complex number\n |  \n |  numerator\n |      the numerator of a rational number in lowest terms\n |  \n |  real\n |      the real part of a complex number"
  },
  {
    "objectID": "vignettes/1_Introduction.html#printing-values",
    "href": "vignettes/1_Introduction.html#printing-values",
    "title": "Basics of Python Programming Language",
    "section": "Printing values",
    "text": "Printing values\nThe print command allows printing messages and also to execute some expressions. Below shows some example usages of the print statement.\nTo print a message or text enclose it within quotation marks.\n\nprint(\"Hello World!\")\n\nHello World!\n\n\nYou can print multiple expressions by separating them with commas. Python will insert a space between each element and a newline at the end of the message.\nYou can change this behaviour using the following two arguments.\n\nsep - takes a character that separates multiple print statements\nend - takes a character to print add the end of the statement.\n\n\nprint(1, 2, 3)\nprint(1, 2, 3, sep='|')\nprint(1, 2, 3, sep=',', end='*')\n\n1 2 3\n1|2|3\n1,2,3*\n\n\nSome additional example usages of print command:\n\nPython provides multiple ways to format numbers using f-strings as follows.\n{data:[align][width][delimiter].[precision]}\n\nAlign: &lt; (left) &gt; (right) ^ (center)\nWidth: number of characters\nDelimiter: 1000s separator (normally , or _)\nPrecision: how many digits displayed for decimal numbers or maximum field width for strings\n\nf is fixed decimal places\ng is significant figures\n\n\nExamples:\n\n# Occupy 10 spaces, align left, show 5 decimal places\nprint(f'This is one way: {22/7:&lt;10.5f}.')\n# Occupy 20 spaces, align center, no decimal places\nprint(f'This is another way: {22/7:^20.0f}.')\n\nThis is one way: 3.14286   .\nThis is another way:          3          .\n\n\nUsing string format method:\n\nprint('First name is {} and the last name is \"{}!\"'.format('john', 'doe'))\n\nFirst name is john and the last name is \"doe!\""
  },
  {
    "objectID": "vignettes/1_Introduction.html#variables-and-assignment",
    "href": "vignettes/1_Introduction.html#variables-and-assignment",
    "title": "Basics of Python Programming Language",
    "section": "Variables and Assignment",
    "text": "Variables and Assignment\nIn the previous examples we directly used numbers and strings. However, we might want to assign values to variables for later usage or to deal with more complex expressions. We can associate a name to a value/expression and access the value/expression through the associated name.\n\nx = 2\nprint(x)\n\n2\n\n\n\ny = 5 * 3\nprint(y)\n\n15\n\n\nWe cannot use arbitrary strings as variables. The Python variable naming rules are:\n\nMust begin with a letter (a - z, A - Z) or underscore (_).\nOther characters can be letters, numbers or _ only.\nNames are case sensitive.\nReserved words cannot be used as a variable name."
  },
  {
    "objectID": "vignettes/1_Introduction.html#basic-data-types",
    "href": "vignettes/1_Introduction.html#basic-data-types",
    "title": "Basics of Python Programming Language",
    "section": "Basic Data Types",
    "text": "Basic Data Types\nThere are three basic numeric types in Python:\n\nPlain integers with unlimited precision (int)\nFloating point numbers or numbers with a decimal point (float)\nComplex numbers (complex)\n\nIn addition, Booleans (bool) are a subtype of integers. They represent truth or false as used in logical operations.\n\nx = 23\ny = -9\nz = complex(3, 5)\nprint(x, y, z)\n\n23 -9 (3+5j)\n\n\n\np = 5.67\nq = -22/7\nr = 2e-3\nprint(p, q, r, sep='\\n')\n\n5.67\n-3.142857142857143\n0.002\n\n\nYou can check the type of values using the built-in function type() as follows.\ntype(0)\ntype(22/7)\ntype(complex(1, 2))\ntype(True)\ntype(False)\n\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'complex'&gt;\n&lt;class 'bool'&gt;\n&lt;class 'bool'&gt;\n\n\nPython converts numbers internally in an expression containing mixed types to a common type for evaluation. But sometimes, we need to coerce a number explicitly from one type to another to satisfy the requirements of an operator or function parameter.\n\nx = \"5\"\nprint(int(x))        # convert x to a plain integer\nprint(float(x))      # convert x to a floating-point number\n\nx = 3\ny = 7\n# convert x to a complex number with real part x and imaginary part zero\nprint(complex(x))    \n# convert x and y to a complex number with real part x and imaginary part y\nprint(complex(x, y)) \n\n5\n5.0\n(3+0j)\n(3+7j)"
  },
  {
    "objectID": "vignettes/1_Introduction.html#sequences",
    "href": "vignettes/1_Introduction.html#sequences",
    "title": "Basics of Python Programming Language",
    "section": "Sequences",
    "text": "Sequences\nThe most basic data structure in Python is the sequence. Sequences are compound data types, and used to group together other values. Each element of a sequence is assigned a number - its position or index. The first index is zero, the second index is one, and so forth.\nThere are certain things you can do with all sequence types. These operations include indexing, slicing, adding, multiplying, and checking for membership. In addition, Python has many built-in functions to be used with sequence types: e.g., for finding the length of a sequence and for finding its largest and smallest elements.\nPython has seven built-in types of sequences (strings, bytes, lists, tuples, bytearrays, buffers, and range objects); the most common one is lists, which we will discuss now.\n\nLists\nThe list is the most versatile data-type available in Python which can be written as a list of comma-separated values (items) between square brackets. Items in a list need not all have the same type. Creating a list is as simple as listing different comma-separated values between square brackets.\n\nlist1 = ['ATG', 'TCA', 23, 12]\nlist2 = [1, 2, 3, 4, 5 ]\nlist3 = [\"a\", \"b\", \"c\", \"d\", 'pqr', 12.345]\n\n\nAccesing values in Lists\nTo access values in lists, use square brackets for slicing along with the index or indices to obtain value available at that index.\n\nlist1 = ['ATG', 'TCA', 23, 12]    # create a list \nprint(\"list1[0] -\", list1[0])     # print the first element in the list\n\nlist2 = [1, 2, 3, 4, 5 ]          # create a list \nprint(\"list2[1:5] -\", list2[1:5]) # print elements from 2 to 6\n\nlist1[0] - ATG\nlist2[1:5] - [2, 3, 4, 5]\n\n\nA few other examples of indexing and slicing:\n\nlist1 = ['Adenine', 'Cytosine', 'Guanine', 'Thymine']\nprint(list1[2])\nprint(list1[-3])\nprint(list1[2:])\nprint(list1[:-2])\n\nGuanine\nCytosine\n['Guanine', 'Thymine']\n['Adenine', 'Cytosine']\n\n\n\n\nUpdating Lists\nYou can update single or multiple elements of lists by giving the slice on the left-hand side of the assignment operator. This will access single or multiple elements as mentioned above. Then, provide the new values that you need to change on the right-hand side of the assignment operator. Make sure the number of accessed elements are the same as the number of assigning (new) elements.\n\nlist1 = ['ATG', 'TCA', 23, 12]              # create a list\nprint(\"Value at index 3 : \", list1[3])      # print the 4th element\n\nlist1[3] = 'GGC'                            # update the 4th element\nprint(\"New value at index 3 : \", list1[3])  # print the 4th element\n\nValue at index 3 :  12\nNew value at index 3 :  GGC\n\n\nAdditionally, you can add elements to the end of a list (even an empty list) with the append() function.\n\nlist1.append('CCG')                         # insert element at the end of the list\nprint(list1)                                # print the list\n\n['ATG', 'TCA', 23, 'GGC', 'CCG']\n\n\n\n\nDeleting List elements\nTo remove a list element, you can use either the del statement if you know exactly which element(s) you are deleting.\n\nprint(\"List of 5 elements =\", list1)          # print list1 \ndel list1[2]                                  # delete element based on its index (3rd element)\nprint(\"After deleting 2nd element =\", list1)  # print list1 \n\nList of 5 elements = ['ATG', 'TCA', 23, 'GGC', 'CCG']\nAfter deleting 2nd element = ['ATG', 'TCA', 'GGC', 'CCG']\n\n\nThe remove() method of a list object can also be used to delete the element based on the value.\n\nlist1.remove('TCA')                           # delete element based on its value ('TCA')\nprint(\"After removing TCA element =\",list1)   # print list1 \n\nAfter removing TCA element = ['ATG', 'GGC', 'CCG']\n\n\nAlternatively, you can use del statement after using the index() function to find the index of the element based on its value:\n\nindx = list1.index('GGC')                     # get index of element 'GGC'\ndel list1[indx]                               # delete element based on its index \nprint(\"After deleting GGC element =\", list1)  # print list1 \n\nAfter deleting GGC element = ['ATG', 'CCG']\n\n\n\n\nOther List operations\nLists respond to the + and * operators (much like strings, discussed next), where ‘+’ means concatenation and ‘*’ means repetition, and the result is a new list. In fact, lists respond to all general sequence operations.\n\nlist1 = [1, 2, 3]\nprint(\"Length of the list =\", len(list1))     # length\n\nLength of the list = 3\n\n\n\nlist2 = [4, 5, 6]\nprint(\"Concatenated list =\", list1 + list2)   # concatenation\n\nConcatenated list = [1, 2, 3, 4, 5, 6]\n\n\n\nprint(\"Repeating list elements =\", list1 * 3) # repetition \n\nRepeating list elements = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\nprint(\"Is 3 a member of list1?\", 3 in list1)  # membership\n\nIs 3 a member of list1? True\n\n\n\nfor x in list1:                               # iteration (discussed in detail later)\n  print(x, end=' ')\n\n1 2 3 \n\n\n\n\n\nStrings\nStrings are amongst the most popular types in Python. We can create them simply by enclosing characters in quotes. Python treats single quotes (’‘) the same as double quotes (““). That is, ‘aaa’ and”aaa” are the same. A string can also be triple quoted, either with three single quotes, as’‘’aaa’’’, or three double quotes, as “““aaa”““.\n\nstr1 = 'This is a string'\nstr2 = \"This is also a string\"\nstr3 = \"\"\"This is a string that extends \nover multiple lines\"\"\"\nprint(str1, str2, str3, sep='\\n')\n\nThis is a string\nThis is also a string\nThis is a string that extends \nover multiple lines\n\n\nStrings can be concatenated (glued together) with the + operator, and repeated with * (similar to lists). This is another way to create new strings.\n\nwords = 'This' + 'is' + 'concatenation' # concatenation\nprint(\"Concatenation =\", words)\nprint(\"Repetition =\", 'ACG' * 3)        # repetition\nprint(\"Length =\", len(words))           # length\nprint(\"Membership =\", \"is\" in words)    # membership\n\nConcatenation = Thisisconcatenation\nRepetition = ACGACGACG\nLength = 19\nMembership = True\n\n\n\nfor x in words:      # iteration (discussed in detail later)\n  print(x, end='|')\n\nT|h|i|s|i|s|c|o|n|c|a|t|e|n|a|t|i|o|n|\n\n\nPython does not support a character type; these are treated as strings of length one, thus also considered a substring. Individual elements can be accessed with an index. Substrings can be specified with the slice notation: two indices separated by a colon.\nStrings can be accessed and manipulated using similar operations we introduced above for lists.\n\nprint(words)\nprint(words[4])\nprint(words[0:6])\nprint(words[6:])\nprint(words[-15:])\n\nThisisconcatenation\ni\nThisis\nconcatenation\nisconcatenation\n\n\n\ntext = \"ATGTCATTTGT\"\ntext[0:2] = \"CCC\"\n\nTypeError: 'str' object does not support item assignment\n\n\nTo change a value in a string, replace() function can be used.\n\nlong_text = \"\"\"Betty bought some butter. \nBut the butter was bitter. \nSo, betty baught more butter to make bitter butter better\"\"\"\nprint(\"Replaced text = \", long_text.replace(\"butter\", \"egg\"))\n\nReplaced text =  Betty bought some egg. \nBut the egg was bitter. \nSo, betty baught more egg to make bitter egg better\n\n\nThe in operator lets you check if a substring is contained within a larger string, but it does not tell you where the substring is located. This is often useful to know and python provides the .find() method which returns the index of the first occurrence of the search string, and the .rfind() method to start searching from the end of the string. If the search string is not found in the string both these methods return -1.\n\ndna = \"ATGTCACCGTTTGGC\"\nprint(\"TCA is at position:\", dna.find(\"TCA\"))\nprint(\"The last Cytosine is at position:\", dna.rfind('C'))\nprint(\"Number of Adenines:\", dna.count(\"A\"))\n\nTCA is at position: 3\nThe last Cytosine is at position: 14\nNumber of Adenines: 2\n\n\nWhen we read text from files (which we will see in the next workshop), often there is unwanted whitespace at the start or end of the string. We can remove leading whitespace with the .lstrip() method, trailing whitespace with .rstrip(), and whitespace from both ends with .strip().\nAll of these methods return a copy of the changed string, so if you want to replace the original you can assign the result of the method call to the original variable.\n\nstring = \"           This is a string with leading and trailing spaces             \"\nprint('|', string, '|')\nprint('|', string.lstrip(), '|')\nprint('|', string.rstrip(), '|')\nprint('|', string.strip(), '|')\n\n|            This is a string with leading and trailing spaces              |\n| This is a string with leading and trailing spaces              |\n|            This is a string with leading and trailing spaces |\n| This is a string with leading and trailing spaces |\n\n\nYou can split a string into a list of substrings using the .split() method, supplying the delimiter as an argument to the method. If you don’t supply any delimiter the method will split the string on whitespace by default (which is very often what you want!)\n\nseq = \"ATG TCA CCG GGC\"\ncodons = seq.split(\" \")\nprint(codons)\n\n['ATG', 'TCA', 'CCG', 'GGC']\n\n\nTo split a string into its component characters you can simply cast the string to a list:\n\nbases = list(seq)\nprint(bases)\n\n['A', 'T', 'G', ' ', 'T', 'C', 'A', ' ', 'C', 'C', 'G', ' ', 'G', 'G', 'C']\n\n\n.split() is the counterpart to the .join() method that lets you join the elements of a list into a string only if all the elements are of type String.\n\nprint(codons)\nprint(\"|\".join(codons))\n\n['ATG', 'TCA', 'CCG', 'GGC']\nATG|TCA|CCG|GGC\n\n\nWe also saw earlier that the + operator lets you concatenate strings together into a larger string. Note that this operator only works on variables of the same type. If you want to concatenate a string with an integer (or some other type), first you have to cast the integer to a string with the str() function.\n\ns = \"chr\"\nchrom_number = 2\nprint(s + str(chrom_number))\n\nchr2\n\n\n\n\nDictionary\nSometimes we want to access data by some useful name rather than an index. For example, as a result of some experiment we may have a set of genes and corresponding expression values. We could put the expression values in a list, but then we’d have to remember which index in the list correspond to which gene and this would quickly get complicated. For these situations a dictionary is a very useful data structure.\nDictionaries contain a mapping of keys to values (like a word and its corresponding definition in a dictionary). The keys of a dictionary are unique (i.e. they cannot repeat). Dictionaries do not store data in any particular order.\n\ndna = {\"A\": \"Adenine\", \"C\": \"Cytosine\", \"G\": \"Guanine\", \"T\": \"Thymine\"}\nprint(dna)\n\n{'A': 'Adenine', 'C': 'Cytosine', 'G': 'Guanine', 'T': 'Thymine'}\n\n\nYou can access values in a dictionary using the key inside square brackets.\n\nprint(\"A represents\", dna[\"A\"])\nprint(\"G represents\", dna[\"G\"])\n\nA represents Adenine\nG represents Guanine\n\n\nAn error is triggered if a key is absent from the dictionary.\n\nprint(\"N represents\", dna[\"N\"])\n\nKeyError: 'N'\n\n\nYou can access values safely with the get method, which gives back None if the key is absent and you can also supply a default values.\n\nprint(\"N represents\", dna.get(\"N\"))\nprint(\"N represents (with a default value)\", dna.get(\"N\", \"unknown\"))\n\nN represents None\nN represents (with a default value) unknown\n\n\nExamples of some operators used with dictionaries.\n\ndna = {\"A\": \"Adenine\", \"C\": \"Cytosine\", \"G\": \"Guanine\", \"T\": \"Thymine\"}\n\n# check if a key is in/not in a dictionary\nprint(\"G\" in dna)\nprint(\"Y\" not in dna)\n\nTrue\nTrue\n\n\n\n# length of a dictionary\nprint(len(dna))\n\n4\n\n\n\nprint(dna)\n# assign new values to a dictionary\ndna['Y'] = 'Pyrimidine'\nprint(dna)\n\n{'A': 'Adenine', 'C': 'Cytosine', 'G': 'Guanine', 'T': 'Thymine'}\n{'A': 'Adenine', 'C': 'Cytosine', 'G': 'Guanine', 'T': 'Thymine', 'Y': 'Pyrimidine'}\n\n\n\n# change value of an existing key\ndna['Y'] = 'Cytosine or Thymine'\nprint(dna)\n\n{'A': 'Adenine', 'C': 'Cytosine', 'G': 'Guanine', 'T': 'Thymine', 'Y': 'Cytosine or Thymine'}\n\n\n\n# list all the keys\nprint(list(dna.keys()))\n# list all values\nprint(list(dna.values()))\n# list all key value pairs\nprint(list(dna.items()))\n\n['A', 'C', 'G', 'T', 'Y']\n['Adenine', 'Cytosine', 'Guanine', 'Thymine', 'Cytosine or Thymine']\n[('A', 'Adenine'), ('C', 'Cytosine'), ('G', 'Guanine'), ('T', 'Thymine'), ('Y', 'Cytosine or Thymine')]"
  },
  {
    "objectID": "vignettes/1_Introduction.html#operators-and-expressions",
    "href": "vignettes/1_Introduction.html#operators-and-expressions",
    "title": "Basics of Python Programming Language",
    "section": "Operators and Expressions",
    "text": "Operators and Expressions\nPython language supports the following types of operators.\n\nArithmetic operators\nComparison (i.e., relational) operators\nAssignment operators\nBitwise operators\nLogical operators\nMembership operators\nIdentity operators\n\nLet’s look at some of these types one by one.\n\nPython Arithmetic Operators\n\n\n\nOperator\nDescription\n\n\n\n\n+\nAddition - Adds values on either side of the operator\n\n\n-\nSubtraction - Subtracts right hand operand from left hand operand\n\n\n*\nMultiplication - Multiplies values on either side of the operator\n\n\n/\nDivision - Divides left hand operand by right hand operand\n\n\n%\nModulus - Divides left hand operand by right hand operand and returns remainder\n\n\n**\nExponent - Performs exponential (power) calculation on operators\n\n\n//\nFloor (or integer) division - Division such that the fractional part of the result is removed, and only the integer part remains.\n\n\n\n\n\nPython Comparison Operators\n\n\n\nOperator\nDescription\n\n\n\n\n==\nChecks if the value of two operands are equal; if yes then condition becomes true.\n\n\n!=\nChecks if the value of two operands are not equal; if values are not equal then condition becomes true.\n\n\n&lt;&gt;\nChecks if the value of two operands are not equal. This is similar to the != operator.\n\n\n&gt;\nChecks if the value of left operand is greater than the value of right operand.\n\n\n&lt;\nChecks if the value of left operand is less than the value of right operand.\n\n\n&gt;=\nChecks if the value of left operand is greater than or equal to the value of right operand.\n\n\n&lt;=\nChecks if the value of left operand is less than or equal to the value of right operand.\n\n\n\n\n\nPython Assignment Operators\n\n\n\nOperator\nDescription\n\n\n\n\n=\nSimple assignment operator, assigns values from right side operands to left side operand\n\n\n+=\nAdd AND assignment operator, it adds right operand to the left operand and assign the result to left operand (Ex: i += 1 is same as i = i + 1)\n\n\n\nSimilar descriptions follow for the remaining arithmetic operators (i.e., -=, *=, /=, %=, **=, //=)\n\n\nPython Logical Operators\n\n\n\nOperator\nDescription\n\n\n\n\nand\nLogical AND operator - If both the operands are true then condition becomes true.\n\n\nor\nLogical OR Operator - If any of the two operands is true (non zero) then condition becomes true.\n\n\nnot\nLogical NOT Operator - Reverses the logical state of its operand. If an expression is true then Logical NOT of that is false.\n\n\n\n\n\nPython Membership Operators\nPython has membership operators, which test for membership in a sequence, such as strings, lists, or tuples. There are two membership operators.\n\n\n\nOperator\nDescription\n\n\n\n\nin\nEvaluates to true if it finds a variable in the specified sequence and false otherwise.\n\n\nnot in\nEvaluates to true if it does not finds a variable in the specified sequence and false otherwise.\n\n\n\n\n\nPython Identity Operators\n\n\n\nOperator\nDescription\n\n\n\n\nis\nEvaluates to true if the variables on either side of the operator point to the same object and false otherwise.\n\n\nis not\nEvaluates to false if the variables on either side of the operator point to the same object and true otherwise.\n\n\n\n\n\nOperator Precedence in Python\nThe following table lists all operators we discussed in this Chapter, from highest precedence to lowest.\n\n\n\nOperator\nDescription\n\n\n\n\n**\nExponentiation\n\n\n~, +, -\nComplement, unary plus and minus (method names for the last two are +@ and -@)\n\n\n*, /, %, //\nMultiply, divide, modulo and floor division\n\n\n+, -\nAddition and subtraction\n\n\n&gt;&gt;, &lt;&lt;\nRight and left bitwise shift\n\n\n&\nBitwise 'AND'\n\n\n^, |\nBitwise exclusive `OR' and regular `OR'\n\n\n&lt;=, &lt;,&gt;, &gt;=\nComparison operators\n\n\n&lt;&gt;, ==, !=\nEquality operators\n\n\n= , %=, /=, //=, -=, +=, *=, **=\nAssignment operators\n\n\nis, is not\nIdentity operators\n\n\nin, not in\nMembership operators\n\n\nnot, or, and\nLogical operators"
  },
  {
    "objectID": "vignettes/1_Introduction.html#control-structures-in-python",
    "href": "vignettes/1_Introduction.html#control-structures-in-python",
    "title": "Basics of Python Programming Language",
    "section": "Control Structures in Python",
    "text": "Control Structures in Python\nIn a program, control flow (or flow of control) refers to the order in which individual statements of the program are executed. Similarly, control flow in an algorithm is the order in which individual steps of the algorithm are executed.\nSo far, we have considered sequential control flow, i.e., statements getting executed from top to bottom, in the order they appear in the program. The sequential flow of control is the default behavior. However, we often need to alter this flow when we write programs, because the problems we can solve with sequential control flow alone are limited to simple (or, as one might say, trivial) problems. In other words, there are many problems that cannot be solved with the sequential control flow alone.\nMany problems that we encounter are complex enough that they require programs with enhanced control flows. For this, most programming languages provide at least three control structures for altering the default sequential flow. These control structures are known as selection, loop, and subprogram. Together with the default sequential flow, we have four control structures for specifying the control flow as shown below.\n\n\n\n\n\n\nSelection Control Structure\n\nif structure\nThe if structure in Python is similar to that of other languages. It contains an expression followed by a set of statements to be executed if the expression is evaluated as true.\nif expression:\n  statement_1\n  statement_2\n  ...\n  statement_n\nNote that, in Python, all statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\n\nif ... else structure\nTo implement the selection control structure shown in subfigure (b) above with both blocks A and B specified, the else keyword can be combined with the if keyword. The else keyword is followed by the code that gets executed if the if-body does not get executed (i.e., conditional expression is not evaluated to true).\nThe else part is optional and there could be at most one else part following an if part. Further, an else part cannot exist alone; it must be paired with an if part.\nif expression:\n  statement(s)\nelse:\n  statement(s)\n\n\nMulti-way Selection with the elif Keyword\nThe elif keyword (meaning “else-if”) allows us to implement multi-way selection, going beyond the two-way selection in the if-else structure. This means, we can select one block of code for execution from among many (&gt; 2). For this, we need to specify multiple conditional expressions for truth value and execute a block of code as soon as the corresponding expression evaluates to true.\nAn elif part is optional and there can be an arbitrary number of elif parts following an if part.\nif expression_1:\n  statement(s)\nelif expression_2:\n  statement(s)  \nelif expression_3:\n  statement(s)  \n...\nelse:\n  statement(s)\nThe if...elif structure is a substitute for the “switch-case” structure in some other languages such as C.\n\n\n\nLoop Control Structure\nPython provides two loop structures: the for loop and the while loop. We can also have nested loops.\n\nThe for loop\nThe for loop construct is used to repeat a statement or block of statements specified number of times. The for loop can also iterate over the items of any sequence (a list or a string), in the order that they appear in the sequence.\nfor iterating_var in sequence:\n   statements(s)\nThe block of statements executed repeatedly is called the loop body. The loop body is indented.\nIf the sequence contains an expression list, it is evaluated first. Then, the first item in the sequence is assigned to the iterating variable iterating_var and the loop body is executed. This concludes one iteration of the loop. Next the second iteration of the loop body is executed after the second item is assigned to the iterating variable iterating_var. Similarly, the loop body is executed repeatedly, with a unique item in the list assigned to iterating_var in each iteration, until the entire sequence is exhausted.\nThe range() function: If we do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates lists containing arithmetic progressions. Implementation of range() is as either range(stop) or range(start, stop[, step]). Here are four examples.\n\nfor i in range(10):\n    print(i, end=' ')\n\n0 1 2 3 4 5 6 7 8 9 \n\n\n\nfor i in range(5, 10):\n    print(i, end=' ')\n\n5 6 7 8 9 \n\n\n\nfor i in range(0, 10, 3):\n    print(i, end=' ')\n\n0 3 6 9 \n\n\n\nfor i in range(-10, -100, -30):\n    print(i, end=' ')\n\n-10 -40 -70 \n\n\nTo iterate over the indices of a list or sequence using a for loop, you can combine range() and len() functions as follows:\n\nlist_a = ['John', 'had', 'a', 'little', 'puppy']\n# using range and len functions\nfor i in range(len(list_a)):\n  print(i, list_a[i])\n\n0 John\n1 had\n2 a\n3 little\n4 puppy\n\n\nOr using enumerate() function:\n\n# using enumerate function\nfor elem in enumerate(list_a):\n  print(elem)\n\n(0, 'John')\n(1, 'had')\n(2, 'a')\n(3, 'little')\n(4, 'puppy')\n\n\n\n\nThe while loop\nA while loop in Python repeatedly executes the loop body as long as a given condition is true. The condition is specified by an expression.\nwhile expression:\n  statement(s)\nThe block of statements executed repeatedly is the loop body, which is indented, as in the for loop.\nThe condition to execute the loop body is considered true if the expression is true or it is any non-zero value. The loop iterates while the condition is true. When the condition becomes false, program control passes to the line immediately following the loop body.\nNote that the while loop might not ever run. When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.\n\n\nThe break keyword\nThe break keyword is used inside a loop and is used for terminating the current iteration of the loop body immediately; i.e., to break out of the smallest enclosing for or while loop. The control will be transferred to the first statement following the loop body. If you are inside the inner loop of a nested loop, then the break statement inside that inner loop transfers the control to the immediate outer loop. The break statement can be used to terminate an infinite loop or to force a loop to end before its normal termination.\n\nn = 10;\nfor var in range(0, n):\n    print(var)\n    if (var == 5):\n        print(\"Countdown Aborted\")\n        break;\n\n0\n1\n2\n3\n4\n5\nCountdown Aborted\n\n\n\n\nThe continue keyword\nThe continue keyword inside a loop causes the program to skip the rest of the loop body in the current iteration, causing it to continue with the next iteration of the loop.\n\nfor i in range(-2,3):\n  if i == 0 :\n      continue\n  print(\"5 divided by \", i, \" is: \", (5.0/i))\n\n5 divided by  -2  is:  -2.5\n5 divided by  -1  is:  -5.0\n5 divided by  1  is:  5.0\n5 divided by  2  is:  2.5"
  },
  {
    "objectID": "vignettes/1_Introduction.html#functions",
    "href": "vignettes/1_Introduction.html#functions",
    "title": "Basics of Python Programming Language",
    "section": "Functions",
    "text": "Functions\nA function is a block of organized, reusable code that is used to perform a single task. Functions are the subprogram control structure in Python. Functions provide better modularity for our programs and a high degree of code reuse.\nAs you already know, Python gives you many built-in functions like print(), etc. But you can also create your own functions which are called user-defined functions.\ndef function_name( parameters ): \n  function_suite\nreturn [expression]\nBy default, parameters have a positional behavior; thus when invoking (calling) the function you need to list them in the same order that they were defined. Defining a function only gives it a name, specifies the parameters that are to be included in the function and structures the blocks of code. Once the function is defined, you can execute it by calling it from your (main) program, another function or directly from the Python prompt.\nIn the following example, we define and call the readDataset() function.\n\n# Function definition to read the cms_hospital_patient_satisfaction_2016_sampled.csv file\n# This function does not require any parameters \ndef readDataset():\n  with open('data/patient_satisfaction/cms_hospital_patient_satisfaction.csv') as f:\n    cms = f.read().splitlines()\n  return cms\n\n# Now you can call readDataset function\ncms = readDataset()\nprint(cms)\n\n['ID,Facility Name,County,Hospital Type,Star Rating,No of Surveys,Response Rate,Overall Rating', '050424,SCRIPPS GREEN HOSPITAL,SAN DIEGO,Acute Care Hospital,4,3110,41,5', '140103,ST BERNARD HOSPITAL,COOK,Acute Care Hospital,1,264,6,2', '100051,SOUTH LAKE HOSPITAL,LAKE,Acute Care Hospital,2,1382,20,2', '040062,MERCY HOSPITAL FORT SMITH,SEBASTIAN,Acute Care Hospital,3,2506,35,3', '440048,BAPTIST MEMORIAL HOSPITAL,SHELBY,Acute Care Hospital,2,1799,18,2', '450011,ST JOSEPH REGIONAL HEALTH CENTER,BRAZOS,Acute Care Hospital,3,1379,24,3', '151317,GREENE COUNTY GENERAL HOSPITAL,GREENE,Critical Access Hospital,3,114,22,3', '061327,SOUTHWEST MEMORIAL HOSPITAL,MONTEZUMA,Critical Access Hospital,4,247,34,3', '490057,SENTARA GENERAL HOSPITAL,VIRGINIA BEACH,Acute Care Hospital,4,619,32,3', '110215,PIEDMONT FAYETTE HOSPITAL,FAYETTE,Acute Care Hospital,2,1714,21,2', '050704,MISSION COMMUNITY HOSPITAL,LOS ANGELES,Acute Care Hospital,3,241,14,3', '100296,DOCTORS HOSPITAL,MIAMI-DADE,Acute Care Hospital,4,393,24,3', '440003,SUMNER REGIONAL MEDICAL CENTER,SUMNER,Acute Care Hospital,4,680,35,2', '501339,WHIDBEY GENERAL HOSPITAL,ISLAND,Critical Access Hospital,3,389,29,3', '050116,NORTHRIDGE MEDICAL CENTER,LOS ANGELES,Acute Care Hospital,3,1110,20,2']\n\n\nIn the following example, we define two functions printHead() and printTail() to print the top 5 and bottom 5 rows of a list. Note that in this example, the return is optional (the program will work even without the return).\n\n# function definition to print the top 5 elements in a list\ndef printHead(inp_list):\n  for i in range(5):\n    print(inp_list[i])\n\n# function definition to print the bottom 5 elements in a list\ndef printTail(inp_list):\n  for i in range(len(inp_list)-5, len(inp_list)):\n    print(inp_list[i])\n\n\n# function call to printHead with melanoma dataset as an input parameter to the function\nprintHead(cms)\n\nID,Facility Name,County,Hospital Type,Star Rating,No of Surveys,Response Rate,Overall Rating\n050424,SCRIPPS GREEN HOSPITAL,SAN DIEGO,Acute Care Hospital,4,3110,41,5\n140103,ST BERNARD HOSPITAL,COOK,Acute Care Hospital,1,264,6,2\n100051,SOUTH LAKE HOSPITAL,LAKE,Acute Care Hospital,2,1382,20,2\n040062,MERCY HOSPITAL FORT SMITH,SEBASTIAN,Acute Care Hospital,3,2506,35,3\n\n\n\n# function call to printTail with melanoma dataset as an input parameter to the function\nprintTail(cms)\n\n050704,MISSION COMMUNITY HOSPITAL,LOS ANGELES,Acute Care Hospital,3,241,14,3\n100296,DOCTORS HOSPITAL,MIAMI-DADE,Acute Care Hospital,4,393,24,3\n440003,SUMNER REGIONAL MEDICAL CENTER,SUMNER,Acute Care Hospital,4,680,35,2\n501339,WHIDBEY GENERAL HOSPITAL,ISLAND,Critical Access Hospital,3,389,29,3\n050116,NORTHRIDGE MEDICAL CENTER,LOS ANGELES,Acute Care Hospital,3,1110,20,2"
  },
  {
    "objectID": "vignettes/Introduction.html",
    "href": "vignettes/Introduction.html",
    "title": "Basics of Python Programming Language",
    "section": "",
    "text": "Python is a dynamic, interpreted general purpose programming language initially created by Guido van Rossum in 1991.\nSupports several popular programming paradigms:\n\nprocedural\nobject-oriented\nfunctional\n\nPython is widely used in bioinformatics and scientific computing, as well as many other fields and in industry.\nSpecifically designed to make programs readable and easy to develop.\nVersatile and easy-to-use language.\nPython is available on all popular operating systems"
  },
  {
    "objectID": "vignettes/Introduction.html#what-is-python",
    "href": "vignettes/Introduction.html#what-is-python",
    "title": "Basics of Python Programming Language",
    "section": "",
    "text": "Python is a dynamic, interpreted general purpose programming language initially created by Guido van Rossum in 1991.\nSupports several popular programming paradigms:\n\nprocedural\nobject-oriented\nfunctional\n\nPython is widely used in bioinformatics and scientific computing, as well as many other fields and in industry.\nSpecifically designed to make programs readable and easy to develop.\nVersatile and easy-to-use language.\nPython is available on all popular operating systems"
  },
  {
    "objectID": "vignettes/Introduction.html#why-learn-python",
    "href": "vignettes/Introduction.html#why-learn-python",
    "title": "Basics of Python Programming Language",
    "section": "Why learn Python?",
    "text": "Why learn Python?\n\nR and Python are the two most popular programming languages used by data analysts and data scientists. Both are free and open source.\nPython is a general-purpose programming language, while R is a statistical programming language.\nGoogle Trend Search Index for R (blue) versus Python (red) over the last 10 years:"
  },
  {
    "objectID": "vignettes/Introduction.html#python-programming-language",
    "href": "vignettes/Introduction.html#python-programming-language",
    "title": "Basics of Python Programming Language",
    "section": "Python Programming Language",
    "text": "Python Programming Language\n\nStandard library provides built-in support for several common tasks:\n\nnumerical & mathematical functions\ninteracting with files and the operating system etc.\n\nHas a rich library:\n\nPandas - Data Manipulation and Analysis\n\nBioPython - For Bioinformatics\nNumPy - Multi-dimensional arrays/matrices along with high-level mathematical functions\nMatplotlib - For Plots\nTensorFlow - Machine Learning and AI"
  },
  {
    "objectID": "vignettes/Introduction.html#how-to-use-python",
    "href": "vignettes/Introduction.html#how-to-use-python",
    "title": "Basics of Python Programming Language",
    "section": "How to use Python?",
    "text": "How to use Python?\n\nInteractive Mode\n\nFirst invoke the Python interpreter and then work with it interactively.\nGive the interpreter Python commands, one at a time.\nTo start the Python interpreter in interactive mode, type the command python on the command-line (shell prompt), as shown below. \n\n\n\nScripting Mode\n\nScripting mode is also called the normal mode (programming mode)\nNon-interactive\nProvide the Python interpreter a text file containing a Python program (script) as input, on the command-line, as follows: \n\n\n\nJupyter Notebook\n\nA web application that allows creating and sharing documents that contain live code, equations, visualizations and explanatory text.\nProvides a rich architecture for interactive data science and scientific computing with:\n\nOver 40 programming languages such as Python, R, Julia and Scala.\nA browser-based notebook with support for code, rich text, math expressions, plots and other rich media.\nSupport for interactive data visualization.\nEasy to use tools for parallel computing.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn this course, we will use Jupyter Notebook (or JupyterLab—the more powerful and extensible evolution of Jupyter Notebook—for all Python coding exercises). Feel free to choose either Jupyter Notebook or JupyterLab based on your preference, as both are widely supported and have similar functionality for the purposes of this course.\n\n\n\n\nAny IDE of your choice\n\n\n\nGoogle search top 10 results: Integrated development environment Software / python"
  },
  {
    "objectID": "vignettes/Introduction.html#a-look-around-jupyter-notebook",
    "href": "vignettes/Introduction.html#a-look-around-jupyter-notebook",
    "title": "Basics of Python Programming Language",
    "section": "A look around Jupyter Notebook",
    "text": "A look around Jupyter Notebook\n\nOpen Jupyter Notebook and create a new notebook as shown below.\n\n\n\n\n\n\n\n\n\nJuptyer has two modes: edit mode (blue cell border) and command mode (grey) cell border).\n\nTo enter edit mode, press Enter or click into a cell. In edit mode, most of the keyboard is dedicated to typing into the cell’s editor. Thus, in edit mode there are relatively few shortcuts.\n\nTo enter command mode, press Esc. In command mode, the entire keyboard is available for shortcuts, so there are many more.\n\n\nTo enter different types of content—such as Markdown, raw text, or Python code, you need to select the appropriate cell type. You can do this by using the drop-down menu in the toolbar at the top of the Jupyter Notebook interface.\n\nCode cells allow you to write and execute Python code.\nMarkdown cells are used to format text with headings, lists, links, and other rich text features.\nRaw cells allow you to input unformatted text that will not be executed or rendered.\n\n\n\n\nShortcuts to execute cells in both modes:\n\nShift + Enter run the current cell \nCtrl + Enter (Mac: Cmd + Enter) run selected cells\nAlt + Enter (Mac: Option + Enter) run the current cell, insert below\nCtrl + S (Mac: Cmd + S) save and checkpoint \n\nSome useful shortcuts, in command mode:\n\nUp select cell above\nDown select cell below\nShift + Up extend selected cells above\nShift + Down extend selected cells below\nA insert cell above \nB insert cell below \nD + D (press the key twice) delete selected cells \n\nThe Help-&gt;Keyboard Shortcuts dialog lists the available shortcuts (or type h in Command mode).\n\n\nTo get started, open Jupyter Notebook and navigate to the IntroPython folder, which was shared with you. Once inside, open the notebook titled IntroPython-Day1.ipynb. This notebook contains the materials and exercises for Day 1 of the course."
  },
  {
    "objectID": "vignettes/Introduction.html#comments",
    "href": "vignettes/Introduction.html#comments",
    "title": "Basics of Python Programming Language",
    "section": "Comments",
    "text": "Comments\nWhen writing code it is very handy to make notes to yourself about what the code is doing. In Python, any text that appears after the hash symbol ‘#’ is called a ‘comment’. Python interpreter can’t see this text, and won’t try to run it as commands. Comments are useful for reminding your future self what you were aiming to do with a particular line of code, and what was or wasn’t working.\n\n# This is a comment"
  },
  {
    "objectID": "vignettes/Introduction.html#help",
    "href": "vignettes/Introduction.html#help",
    "title": "Basics of Python Programming Language",
    "section": "Help",
    "text": "Help\nThe Python help() function invokes the interactive built-in help system. If the argument is a string, then the string is treated as the name of a module, function, class, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is displayed.\nIt’s recommended to try it in your interpreter when you need help to write Python program and use Python modules.\nThe following displays the help on the builtin print function.\n\nhelp('print')\n\nThe following displays the help page on the math module (or library).\n\n\nhelp('math')\n\n\nThe help function can also be used on built-in or user-defined classes.\n\n\nhelp('int')"
  },
  {
    "objectID": "vignettes/Introduction.html#printing-values",
    "href": "vignettes/Introduction.html#printing-values",
    "title": "Basics of Python Programming Language",
    "section": "Printing values",
    "text": "Printing values\nThe print command allows printing messages and also to execute some expressions. Below shows some example usages of the print statement.\nTo print a message or text enclose it within quotation marks.\n\nprint(\"Hello World!\")\n\nYou can print multiple expressions by separating them with commas. Python will insert a space between each element and a newline at the end of the message.\nYou can change this behaviour using the following two arguments.\n\nsep - takes a character that separates multiple print statements\nend - takes a character to print add the end of the statement.\n\n\nprint(1, 2, 3)\nprint(1, 2, 3, sep='|')\nprint(1, 2, 3, sep=',', end='*')\n\nSome additional example usages of print command:\n\nPython provides multiple ways to format numbers using f-strings as follows.\n{data:[align][width][delimiter].[precision]}\n\nAlign: &lt; (left) &gt; (right) ^ (center)\nWidth: number of characters\nDelimiter: 1000s separator (normally , or _)\nPrecision: how many digits displayed for decimal numbers or maximum field width for strings\n\nf is fixed decimal places\ng is significant figures\n\n\nExamples:\n\n# Occupy 10 spaces, align left, show 5 decimal places\nprint(f'This is one way: {22/7:&lt;10.5f}.')\n# Occupy 20 spaces, align center, no decimal places\nprint(f'This is another way: {22/7:^20.0f}.')\n\nUsing string format method:\n\nprint('First name is {} and the last name is \"{}!\"'.format('john', 'doe'))"
  },
  {
    "objectID": "vignettes/Introduction.html#variables-and-assignment",
    "href": "vignettes/Introduction.html#variables-and-assignment",
    "title": "Basics of Python Programming Language",
    "section": "Variables and Assignment",
    "text": "Variables and Assignment\nIn the previous examples we directly used numbers and strings. However, we might want to assign values to variables for later usage or to deal with more complex expressions. We can associate a name to a value/expression and access the value/expression through the associated name.\n\nx = 2\nprint(x)\n\n\ny = 5 * 3\nprint(y)\n\nWe cannot use arbitrary strings as variables. The Python variable naming rules are:\n\nMust begin with a letter (a - z, A - Z) or underscore (_).\nOther characters can be letters, numbers or _ only.\nNames are case sensitive.\nReserved words cannot be used as a variable name."
  },
  {
    "objectID": "vignettes/Introduction.html#basic-data-types",
    "href": "vignettes/Introduction.html#basic-data-types",
    "title": "Basics of Python Programming Language",
    "section": "Basic Data Types",
    "text": "Basic Data Types\nThere are three basic numeric types in Python:\n\nPlain integers with unlimited precision (int)\nFloating point numbers or numbers with a decimal point (float)\nComplex numbers (complex)\n\nIn addition, Booleans (bool) are a subtype of integers. They represent truth or false as used in logical operations.\n\nx = 23\ny = -9\nz = complex(3, 5)\nprint(x, y, z)\n\n\np = 5.67\nq = -22/7\nr = 2e-3\nprint(p, q, r, sep='\\n')\n\nYou can check the type of values using the built-in function type() as follows.\ntype(0)\ntype(22/7)\ntype(complex(1, 2))\ntype(True)\ntype(False)\nPython converts numbers internally in an expression containing mixed types to a common type for evaluation. But sometimes, we need to coerce a number explicitly from one type to another to satisfy the requirements of an operator or function parameter.\n\nx = \"5\"\nprint(int(x))        # convert x to a plain integer\nprint(float(x))      # convert x to a floating-point number\n\nx = 3\ny = 7\n# convert x to a complex number with real part x and imaginary part zero\nprint(complex(x))    \n# convert x and y to a complex number with real part x and imaginary part y\nprint(complex(x, y))"
  },
  {
    "objectID": "vignettes/Introduction.html#sequences",
    "href": "vignettes/Introduction.html#sequences",
    "title": "Basics of Python Programming Language",
    "section": "Sequences",
    "text": "Sequences\nThe most basic data structure in Python is the sequence. Sequences are compound data types, and used to group together other values. Each element of a sequence is assigned a number - its position or index. The first index is zero, the second index is one, and so forth.\nThere are certain things you can do with all sequence types. These operations include indexing, slicing, adding, multiplying, and checking for membership. In addition, Python has many built-in functions to be used with sequence types: e.g., for finding the length of a sequence and for finding its largest and smallest elements.\nPython has seven built-in types of sequences (strings, bytes, lists, tuples, bytearrays, buffers, and range objects); the most common one is lists, which we will discuss now.\n\nLists\nThe list is the most versatile data-type available in Python which can be written as a list of comma-separated values (items) between square brackets. Items in a list need not all have the same type. Creating a list is as simple as listing different comma-separated values between square brackets.\n\nlist1 = ['ATG', 'TCA', 23, 12]\nlist2 = [1, 2, 3, 4, 5 ]\nlist3 = [\"a\", \"b\", \"c\", \"d\", 'pqr', 12.345]\n\n\nAccesing values in Lists\nTo access values in lists, use square brackets for slicing along with the index or indices to obtain value available at that index.\n\nlist1 = ['ATG', 'TCA', 23, 12]    # create a list \nprint(\"list1[0] -\", list1[0])     # print the first element in the list\n\nlist2 = [1, 2, 3, 4, 5 ]          # create a list \nprint(\"list2[1:5] -\", list2[1:5]) # print elements from 2 to 6\n\nA few other examples of indexing and slicing:\n\nlist1 = ['Adenine', 'Cytosine', 'Guanine', 'Thymine']\nprint(list1[2])\nprint(list1[-3])\nprint(list1[2:])\nprint(list1[:-2])\n\n\n\nUpdating Lists\nYou can update single or multiple elements of lists by giving the slice on the left-hand side of the assignment operator. This will access single or multiple elements as mentioned above. Then, provide the new values that you need to change on the right-hand side of the assignment operator. Make sure the number of accessed elements are the same as the number of assigning (new) elements.\n\nlist1 = ['ATG', 'TCA', 23, 12]              # create a list\nprint(\"Value at index 3 : \", list1[3])      # print the 4th element\n\nlist1[3] = 'GGC'                            # update the 4th element\nprint(\"New value at index 3 : \", list1[3])  # print the 4th element\n\nAdditionally, you can add elements to the end of a list (even an empty list) with the append() function.\n\nlist1.append('CCG')                         # insert element at the end of the list\nprint(list1)                                # print the list\n\n\n\nDeleting List elements\nTo remove a list element, you can use either the del statement if you know exactly which element(s) you are deleting.\n\nprint(\"List of 5 elements =\", list1)          # print list1 \ndel list1[2]                                  # delete element based on its index (3rd element)\nprint(\"After deleting 2nd element =\", list1)  # print list1 \n\nThe remove() method of a list object can also be used to delete the element based on the value.\n\nlist1.remove('TCA')                           # delete element based on its value ('TCA')\nprint(\"After removing TCA element =\",list1)   # print list1 \n\nAlternatively, you can use del statement after using the index() function to find the index of the element based on its value:\n\nindx = list1.index('GGC')                     # get index of element 'GGC'\ndel list1[indx]                               # delete element based on its index \nprint(\"After deleting GGC element =\", list1)  # print list1 \n\n\n\nOther List operations\nLists respond to the + and * operators (much like strings, discussed next), where ‘+’ means concatenation and ‘*’ means repetition, and the result is a new list. In fact, lists respond to all general sequence operations.\n\nlist1 = [1, 2, 3]\nprint(\"Length of the list =\", len(list1))     # length\n\n\nlist2 = [4, 5, 6]\nprint(\"Concatenated list =\", list1 + list2)   # concatenation\n\n\nprint(\"Repeating list elements =\", list1 * 3) # repetition \n\n\nprint(\"Is 3 a member of list1?\", 3 in list1)  # membership\n\n\nfor x in list1:                               # iteration (discussed in detail later)\n  print(x, end=' ')\n\n\n\n\nStrings\nStrings are amongst the most popular types in Python. We can create them simply by enclosing characters in quotes. Python treats single quotes (’‘) the same as double quotes (““). That is, ‘aaa’ and”aaa” are the same. A string can also be triple quoted, either with three single quotes, as’‘’aaa’’’, or three double quotes, as “““aaa”““.\n\nstr1 = 'This is a string'\nstr2 = \"This is also a string\"\nstr3 = \"\"\"This is a string that extends \nover multiple lines\"\"\"\nprint(str1, str2, str3, sep='\\n')\n\nStrings can be concatenated (glued together) with the + operator, and repeated with * (similar to lists). This is another way to create new strings.\n\nwords = 'This' + 'is' + 'concatenation' # concatenation\nprint(\"Concatenation =\", words)\nprint(\"Repetition =\", 'ACG' * 3)        # repetition\nprint(\"Length =\", len(words))           # length\nprint(\"Membership =\", \"is\" in words)    # membership\n\n\nfor x in words:      # iteration (discussed in detail later)\n  print(x, end='|')\n\nPython does not support a character type; these are treated as strings of length one, thus also considered a substring. Individual elements can be accessed with an index. Substrings can be specified with the slice notation: two indices separated by a colon.\nStrings can be accessed and manipulated using similar operations we introduced above for lists.\n\nprint(words)\nprint(words[4])\nprint(words[0:6])\nprint(words[6:])\nprint(words[-15:])\n\n\ntext = \"ATGTCATTTGT\"\ntext[0:2] = \"CCC\"\n\nTo change a value in a string, replace() function can be used.\n\nlong_text = \"\"\"Betty bought some butter. \nBut the butter was bitter. \nSo, betty baught more butter to make bitter butter better\"\"\"\nprint(\"Replaced text = \", long_text.replace(\"butter\", \"egg\"))\n\nThe in operator lets you check if a substring is contained within a larger string, but it does not tell you where the substring is located. This is often useful to know and python provides the .find() method which returns the index of the first occurrence of the search string, and the .rfind() method to start searching from the end of the string. If the search string is not found in the string both these methods return -1.\n\ndna = \"ATGTCACCGTTTGGC\"\nprint(\"TCA is at position:\", dna.find(\"TCA\"))\nprint(\"The last Cytosine is at position:\", dna.rfind('C'))\nprint(\"Number of Adenines:\", dna.count(\"A\"))\n\nWhen we read text from files (which we will see in the next workshop), often there is unwanted whitespace at the start or end of the string. We can remove leading whitespace with the .lstrip() method, trailing whitespace with .rstrip(), and whitespace from both ends with .strip().\nAll of these methods return a copy of the changed string, so if you want to replace the original you can assign the result of the method call to the original variable.\n\nstring = \"           This is a string with leading and trailing spaces             \"\nprint('|', string, '|')\nprint('|', string.lstrip(), '|')\nprint('|', string.rstrip(), '|')\nprint('|', string.strip(), '|')\n\nYou can split a string into a list of substrings using the .split() method, supplying the delimiter as an argument to the method. If you don’t supply any delimiter the method will split the string on whitespace by default (which is very often what you want!)\n\nseq = \"ATG TCA CCG GGC\"\ncodons = seq.split(\" \")\nprint(codons)\n\nTo split a string into its component characters you can simply cast the string to a list:\n\nbases = list(seq)\nprint(bases)\n\n.split() is the counterpart to the .join() method that lets you join the elements of a list into a string only if all the elements are of type String.\n\nprint(codons)\nprint(\"|\".join(codons))\n\nWe also saw earlier that the + operator lets you concatenate strings together into a larger string. Note that this operator only works on variables of the same type. If you want to concatenate a string with an integer (or some other type), first you have to cast the integer to a string with the str() function.\n\ns = \"chr\"\nchrom_number = 2\nprint(s + str(chrom_number))\n\n\n\nDictionary\nSometimes we want to access data by some useful name rather than an index. For example, as a result of some experiment we may have a set of genes and corresponding expression values. We could put the expression values in a list, but then we’d have to remember which index in the list correspond to which gene and this would quickly get complicated. For these situations a dictionary is a very useful data structure.\nDictionaries contain a mapping of keys to values (like a word and its corresponding definition in a dictionary). The keys of a dictionary are unique (i.e. they cannot repeat). Dictionaries do not store data in any particular order.\n\ndna = {\"A\": \"Adenine\", \"C\": \"Cytosine\", \"G\": \"Guanine\", \"T\": \"Thymine\"}\nprint(dna)\n\nYou can access values in a dictionary using the key inside square brackets.\n\nprint(\"A represents\", dna[\"A\"])\nprint(\"G represents\", dna[\"G\"])\n\nAn error is triggered if a key is absent from the dictionary.\n\nprint(\"N represents\", dna[\"N\"])\n\nYou can access values safely with the get method, which gives back None if the key is absent and you can also supply a default values.\n\nprint(\"N represents\", dna.get(\"N\"))\nprint(\"N represents (with a default value)\", dna.get(\"N\", \"unknown\"))\n\nExamples of some operators used with dictionaries.\n\ndna = {\"A\": \"Adenine\", \"C\": \"Cytosine\", \"G\": \"Guanine\", \"T\": \"Thymine\"}\n\n# check if a key is in/not in a dictionary\nprint(\"G\" in dna)\nprint(\"Y\" not in dna)\n\n\n# length of a dictionary\nprint(len(dna))\n\n\nprint(dna)\n# assign new values to a dictionary\ndna['Y'] = 'Pyrimidine'\nprint(dna)\n\n\n# change value of an existing key\ndna['Y'] = 'Cytosine or Thymine'\nprint(dna)\n\n\n# list all the keys\nprint(list(dna.keys()))\n# list all values\nprint(list(dna.values()))\n# list all key value pairs\nprint(list(dna.items()))"
  },
  {
    "objectID": "vignettes/Introduction.html#operators-and-expressions",
    "href": "vignettes/Introduction.html#operators-and-expressions",
    "title": "Basics of Python Programming Language",
    "section": "Operators and Expressions",
    "text": "Operators and Expressions\nPython language supports the following types of operators.\n\nArithmetic operators\nComparison (i.e., relational) operators\nAssignment operators\nBitwise operators\nLogical operators\nMembership operators\nIdentity operators\n\nLet’s look at some of these types one by one.\n\nPython Arithmetic Operators\n\n\n\nOperator\nDescription\n\n\n\n\n+\nAddition - Adds values on either side of the operator\n\n\n-\nSubtraction - Subtracts right hand operand from left hand operand\n\n\n*\nMultiplication - Multiplies values on either side of the operator\n\n\n/\nDivision - Divides left hand operand by right hand operand\n\n\n%\nModulus - Divides left hand operand by right hand operand and returns remainder\n\n\n**\nExponent - Performs exponential (power) calculation on operators\n\n\n//\nFloor (or integer) division - Division such that the fractional part of the result is removed, and only the integer part remains.\n\n\n\n\n\nPython Comparison Operators\n\n\n\nOperator\nDescription\n\n\n\n\n==\nChecks if the value of two operands are equal; if yes then condition becomes true.\n\n\n!=\nChecks if the value of two operands are not equal; if values are not equal then condition becomes true.\n\n\n&lt;&gt;\nChecks if the value of two operands are not equal. This is similar to the != operator.\n\n\n&gt;\nChecks if the value of left operand is greater than the value of right operand.\n\n\n&lt;\nChecks if the value of left operand is less than the value of right operand.\n\n\n&gt;=\nChecks if the value of left operand is greater than or equal to the value of right operand.\n\n\n&lt;=\nChecks if the value of left operand is less than or equal to the value of right operand.\n\n\n\n\n\nPython Assignment Operators\n\n\n\nOperator\nDescription\n\n\n\n\n=\nSimple assignment operator, assigns values from right side operands to left side operand\n\n\n+=\nAdd AND assignment operator, it adds right operand to the left operand and assign the result to left operand (Ex: i += 1 is same as i = i + 1)\n\n\n\nSimilar descriptions follow for the remaining arithmetic operators (i.e., -=, *=, /=, %=, **=, //=)\n\n\nPython Logical Operators\n\n\n\nOperator\nDescription\n\n\n\n\nand\nLogical AND operator - If both the operands are true then condition becomes true.\n\n\nor\nLogical OR Operator - If any of the two operands is true (non zero) then condition becomes true.\n\n\nnot\nLogical NOT Operator - Reverses the logical state of its operand. If an expression is true then Logical NOT of that is false.\n\n\n\n\n\nPython Membership Operators\nPython has membership operators, which test for membership in a sequence, such as strings, lists, or tuples. There are two membership operators.\n\n\n\nOperator\nDescription\n\n\n\n\nin\nEvaluates to true if it finds a variable in the specified sequence and false otherwise.\n\n\nnot in\nEvaluates to true if it does not finds a variable in the specified sequence and false otherwise.\n\n\n\n\n\nPython Identity Operators\n\n\n\nOperator\nDescription\n\n\n\n\nis\nEvaluates to true if the variables on either side of the operator point to the same object and false otherwise.\n\n\nis not\nEvaluates to false if the variables on either side of the operator point to the same object and true otherwise.\n\n\n\n\n\nOperator Precedence in Python\nThe following table lists all operators we discussed in this Chapter, from highest precedence to lowest.\n\n\n\nOperator\nDescription\n\n\n\n\n**\nExponentiation\n\n\n~, +, -\nComplement, unary plus and minus (method names for the last two are +@ and -@)\n\n\n*, /, %, //\nMultiply, divide, modulo and floor division\n\n\n+, -\nAddition and subtraction\n\n\n&gt;&gt;, &lt;&lt;\nRight and left bitwise shift\n\n\n&\nBitwise 'AND'\n\n\n^, |\nBitwise exclusive `OR' and regular `OR'\n\n\n&lt;=, &lt;,&gt;, &gt;=\nComparison operators\n\n\n&lt;&gt;, ==, !=\nEquality operators\n\n\n= , %=, /=, //=, -=, +=, *=, **=\nAssignment operators\n\n\nis, is not\nIdentity operators\n\n\nin, not in\nMembership operators\n\n\nnot, or, and\nLogical operators"
  },
  {
    "objectID": "vignettes/Introduction.html#control-structures-in-python",
    "href": "vignettes/Introduction.html#control-structures-in-python",
    "title": "Basics of Python Programming Language",
    "section": "Control Structures in Python",
    "text": "Control Structures in Python\nIn a program, control flow (or flow of control) refers to the order in which individual statements of the program are executed. Similarly, control flow in an algorithm is the order in which individual steps of the algorithm are executed.\nSo far, we have considered sequential control flow, i.e., statements getting executed from top to bottom, in the order they appear in the program. The sequential flow of control is the default behavior. However, we often need to alter this flow when we write programs, because the problems we can solve with sequential control flow alone are limited to simple (or, as one might say, trivial) problems. In other words, there are many problems that cannot be solved with the sequential control flow alone.\nMany problems that we encounter are complex enough that they require programs with enhanced control flows. For this, most programming languages provide at least three control structures for altering the default sequential flow. These control structures are known as selection, loop, and subprogram. Together with the default sequential flow, we have four control structures for specifying the control flow as shown below.\n\n\n\n\n\n\nSelection Control Structure\n\nif structure\nThe if structure in Python is similar to that of other languages. It contains an expression followed by a set of statements to be executed if the expression is evaluated as true.\nif expression:\n  statement_1\n  statement_2\n  ...\n  statement_n\nNote that, in Python, all statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\n\nif ... else structure\nTo implement the selection control structure shown in subfigure (b) above with both blocks A and B specified, the else keyword can be combined with the if keyword. The else keyword is followed by the code that gets executed if the if-body does not get executed (i.e., conditional expression is not evaluated to true).\nThe else part is optional and there could be at most one else part following an if part. Further, an else part cannot exist alone; it must be paired with an if part.\nif expression:\n  statement(s)\nelse:\n  statement(s)\n\n\nMulti-way Selection with the elif Keyword\nThe elif keyword (meaning “else-if”) allows us to implement multi-way selection, going beyond the two-way selection in the if-else structure. This means, we can select one block of code for execution from among many (&gt; 2). For this, we need to specify multiple conditional expressions for truth value and execute a block of code as soon as the corresponding expression evaluates to true.\nAn elif part is optional and there can be an arbitrary number of elif parts following an if part.\nif expression_1:\n  statement(s)\nelif expression_2:\n  statement(s)  \nelif expression_3:\n  statement(s)  \n...\nelse:\n  statement(s)\nThe if...elif structure is a substitute for the “switch-case” structure in some other languages such as C.\n\n\n\nLoop Control Structure\nPython provides two loop structures: the for loop and the while loop. We can also have nested loops.\n\nThe for loop\nThe for loop construct is used to repeat a statement or block of statements specified number of times. The for loop can also iterate over the items of any sequence (a list or a string), in the order that they appear in the sequence.\nfor iterating_var in sequence:\n   statements(s)\nThe block of statements executed repeatedly is called the loop body. The loop body is indented.\nIf the sequence contains an expression list, it is evaluated first. Then, the first item in the sequence is assigned to the iterating variable iterating_var and the loop body is executed. This concludes one iteration of the loop. Next the second iteration of the loop body is executed after the second item is assigned to the iterating variable iterating_var. Similarly, the loop body is executed repeatedly, with a unique item in the list assigned to iterating_var in each iteration, until the entire sequence is exhausted.\nThe range() function: If we do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates lists containing arithmetic progressions. Implementation of range() is as either range(stop) or range(start, stop[, step]). Here are four examples.\n\nfor i in range(10):\n    print(i, end=' ')\n\n\nfor i in range(5, 10):\n    print(i, end=' ')\n\n\nfor i in range(0, 10, 3):\n    print(i, end=' ')\n\n\nfor i in range(-10, -100, -30):\n    print(i, end=' ')\n\nTo iterate over the indices of a list or sequence using a for loop, you can combine range() and len() functions as follows:\n\nlist_a = ['John', 'had', 'a', 'little', 'puppy']\n# using range and len functions\nfor i in range(len(list_a)):\n  print(i, list_a[i])\n\nOr using enumerate() function:\n\n# using enumerate function\nfor elem in enumerate(list_a):\n  print(elem)\n\n\n\nThe while loop\nA while loop in Python repeatedly executes the loop body as long as a given condition is true. The condition is specified by an expression.\nwhile expression:\n  statement(s)\nThe block of statements executed repeatedly is the loop body, which is indented, as in the for loop.\nThe condition to execute the loop body is considered true if the expression is true or it is any non-zero value. The loop iterates while the condition is true. When the condition becomes false, program control passes to the line immediately following the loop body.\nNote that the while loop might not ever run. When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.\n\n\nThe break keyword\nThe break keyword is used inside a loop and is used for terminating the current iteration of the loop body immediately; i.e., to break out of the smallest enclosing for or while loop. The control will be transferred to the first statement following the loop body. If you are inside the inner loop of a nested loop, then the break statement inside that inner loop transfers the control to the immediate outer loop. The break statement can be used to terminate an infinite loop or to force a loop to end before its normal termination.\n\nn = 10;\nfor var in range(0, n):\n    print(var)\n    if (var == 5):\n        print(\"Countdown Aborted\")\n        break;\n\n\n\nThe continue keyword\nThe continue keyword inside a loop causes the program to skip the rest of the loop body in the current iteration, causing it to continue with the next iteration of the loop.\n\nfor i in range(-2,3):\n  if i == 0 :\n      continue\n  print(\"5 divided by \", i, \" is: \", (5.0/i))"
  },
  {
    "objectID": "vignettes/Introduction.html#functions",
    "href": "vignettes/Introduction.html#functions",
    "title": "Basics of Python Programming Language",
    "section": "Functions",
    "text": "Functions\nA function is a block of organized, reusable code that is used to perform a single task. Functions are the subprogram control structure in Python. Functions provide better modularity for our programs and a high degree of code reuse.\nAs you already know, Python gives you many built-in functions like print(), etc. But you can also create your own functions which are called user-defined functions.\ndef function_name( parameters ): \n  function_suite\nreturn [expression]\nBy default, parameters have a positional behavior; thus when invoking (calling) the function you need to list them in the same order that they were defined. Defining a function only gives it a name, specifies the parameters that are to be included in the function and structures the blocks of code. Once the function is defined, you can execute it by calling it from your (main) program, another function or directly from the Python prompt.\nIn the following example, we define and call the readDataset() function.\n\n# Function definition to read the cms_hospital_patient_satisfaction_2016_sampled.csv file\n# This function does not require any parameters \ndef readDataset():\n  with open('data/patient_satisfaction/cms_hospital_patient_satisfaction_2016_sampled.csv') as f:\n    cms = f.read().splitlines()\n  return cms\n\n# Now you can call readDataset function\ncms = readDataset()\nprint(cms)\n\nIn the following example, we define two functions printHead() and printTail() to print the top 5 and bottom 5 rows of a list. Note that in this example, the return is optional (the program will work even without the return).\n\n# function definition to print the top 5 elements in a list\ndef printHead(inp_list):\n  for i in range(5):\n    print(inp_list[i])\n\n# function definition to print the bottom 5 elements in a list\ndef printTail(inp_list):\n  for i in range(len(inp_list)-5, len(inp_list)):\n    print(inp_list[i])\n\n\n# function call to printHead with melanoma dataset as an input parameter to the function\nprintHead(cms)\n\n\n# function call to printTail with melanoma dataset as an input parameter to the function\nprintTail(cms)"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html",
    "href": "vignettes/2_Reading_tidying_data.html",
    "title": "Reading and Tidying Data",
    "section": "",
    "text": "Pandas is a powerful and widely used library in Python for data manipulation and analysis. It provides versatile data structures, such as DataFrames and Series, along with a variety of functions and methods for efficiently handling and processing structured data. In this session, we explore some functionalities of Pandas library that is useful for biological data analysis.\nCustomarily, we import the library as follows:\n\nimport pandas as pd"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#getting-started-with-pandas",
    "href": "vignettes/2_Reading_tidying_data.html#getting-started-with-pandas",
    "title": "Reading and Tidying Data",
    "section": "",
    "text": "Pandas is a powerful and widely used library in Python for data manipulation and analysis. It provides versatile data structures, such as DataFrames and Series, along with a variety of functions and methods for efficiently handling and processing structured data. In this session, we explore some functionalities of Pandas library that is useful for biological data analysis.\nCustomarily, we import the library as follows:\n\nimport pandas as pd"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#basic-data-structures-in-pandas",
    "href": "vignettes/2_Reading_tidying_data.html#basic-data-structures-in-pandas",
    "title": "Reading and Tidying Data",
    "section": "Basic data structures in pandas",
    "text": "Basic data structures in pandas\nPandas provides two types of classes for handling data: Series and DataFrame.\n\nSeries\nSeries is a one-dimensional labeled array capable of holding any data type (integers, strings, floating point numbers, Python objects, etc.). The axis labels are collectively referred to as the index. The basic method to create a Series is to call:\ns = pd.Series(data, index=index)\nHere, data can be a Python dict, an ndarray (a multidimensional container of items of the same type and size) or a scalar value. The passed index is a list of axis labels.\n\nUsing a list:\n\ns1 = pd.Series([1, 3, 5, 6, 8])\ns1\n\n0    1\n1    3\n2    5\n3    6\n4    8\ndtype: int64\n\n\n\n\nUsing a scalar (single value):\n\ns2 = pd.Series(5.0, index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\ns2\n\na    5.0\nb    5.0\nc    5.0\nd    5.0\ne    5.0\ndtype: float64\n\n\n\n\nUsing a numpy array:\nTo create a Series using ndarray first import numpy library.\n\nimport numpy as np\n\nNumPy, short for Numerical Python, is a fundamental Python library for scientific computing. It provides support for working with large, multi-dimensional arrays and matrices, as well as a collection of high-level mathematical functions to operate on these arrays.\n\ns3 = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\ns3\n\na   -0.145212\nb    1.174687\nc    0.292096\nd   -1.181543\ne   -0.895338\ndtype: float64\n\n\nThe np.random module in NumPy is designed for generating pseudo-random numbers, enabling you to extract samples from a wide range of probability distributions. Specifically, the np.random.randn function is used to obtain one or more samples from the “standard normal” distribution, characterized by a mean of 0 and a variance of 1.\nIf data is an ndarray, index must be the same length as data. If no index is passed, one will be created having values [0, …, len(data) - 1].\n\ns3 = pd.Series(np.random.randn(5))\ns3\n\n0    0.010455\n1    0.204012\n2   -1.422487\n3    0.126631\n4    0.746505\ndtype: float64\n\n\n\n\nUsing a dictionary:\nSeries can be instantiated from dicts (recall dictionary from last week) as follows:\n\nd = {\"A\": 248, \"C\": 243, \"G\": 266, \"T\": 243}\ns4 = pd.Series(d)\ns4\n\nA    248\nC    243\nG    266\nT    243\ndtype: int64\n\n\n\ns4 = pd.Series(dict, index=[\"A\", \"B\", \"C\"])\ns4\n\nA    &lt;class 'dict'&gt;\nB    &lt;class 'dict'&gt;\nC    &lt;class 'dict'&gt;\ndtype: object\n\n\n\n\n\nDataFrame\nDataFrame is a 2-dimensional labeled data structure with columns of potentially different types. You can think of it like a spreadsheet or SQL table, or a dict of Series objects. The DataFrame is generally the most commonly used pandas object. It accepts many different types of input including dictionary of 1-D ndarrays, lists, dictionaries or Series, 2-D ndarray, a Series or even another DataFrame.\nAlong with the data, you can optionally pass index (row labels) and columns (column labels) arguments. If you pass an index and/or columns, you are guaranteeing the index and/or columns of the resulting DataFrame.\nThe basic method to create a DataFrame is to call:\ndf = pd.DataFrame(data, index=index, columns=columns)\n\nCreating a DataFrame by using a dictionary of Series:\n\n# a dictionary of series\nd = {\n    \"Col 1\": pd.Series([1.0, 2.0, 3.0], index=[\"a\", \"b\", \"c\"]),\n    \"Col 2\": pd.Series([1.0, 2.0, 3.0, 4.0], index=[\"a\", \"b\", \"c\", \"d\"]),\n}\ndf1 = pd.DataFrame(d)\ndf1\n\n\n\n\n\n\n\n\nCol 1\nCol 2\n\n\n\n\na\n1.0\n1.0\n\n\nb\n2.0\n2.0\n\n\nc\n3.0\n3.0\n\n\nd\nNaN\n4.0\n\n\n\n\n\n\n\n\n# table with rows: d, b  and a of the above dictionary\ndf2 = pd.DataFrame(d, index=[\"d\", \"b\", \"a\"])\ndf2\n\n\n\n\n\n\n\n\nCol 1\nCol 2\n\n\n\n\nd\nNaN\n4.0\n\n\nb\n2.0\n2.0\n\n\na\n1.0\n1.0\n\n\n\n\n\n\n\nNote: NaN, standing for not a number, is a numeric data type used to represent any value that is undefined. It is by default not included in computations.\n\n\nCreating a DataFrame by using a dictionary of Series, lists, ndarrays:\n\n# a dictionary \ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'Age': pd.Series([25, 30, 35, 40]),\n    'City': ['New York', 'Los Angeles', 'Chicago', 'Houston'],\n    'Salary': np.array([50000, 60000, 75000, 90000])\n}\n\ndf3 = pd.DataFrame(data)\ndf3\n\n\n\n\n\n\n\n\nName\nAge\nCity\nSalary\n\n\n\n\n0\nAlice\n25\nNew York\n50000\n\n\n1\nBob\n30\nLos Angeles\n60000\n\n\n2\nCharlie\n35\nChicago\n75000\n\n\n3\nDavid\n40\nHouston\n90000\n\n\n\n\n\n\n\n\n\n\nIndexes and Columns of DataFrames\nConsider the following DataFrame,\n\nd = {\"one\": [1.0, 2.0, 3.0, 4.0], \"two\": [4.0, 3.0, 2.0, 1.0]}\ndf3 = pd.DataFrame(d, index=[\"a\", \"b\", \"c\", \"d\"])\ndf3\n\n\n\n\n\n\n\n\none\ntwo\n\n\n\n\na\n1.0\n4.0\n\n\nb\n2.0\n3.0\n\n\nc\n3.0\n2.0\n\n\nd\n4.0\n1.0\n\n\n\n\n\n\n\nTo print and update row names:\n\ndf3.index = [\"row 1\", \"row 2\", \"row 3\", \"row 4\"]\ndf3\n\n\n\n\n\n\n\n\none\ntwo\n\n\n\n\nrow 1\n1.0\n4.0\n\n\nrow 2\n2.0\n3.0\n\n\nrow 3\n3.0\n2.0\n\n\nrow 4\n4.0\n1.0\n\n\n\n\n\n\n\nTo print and update column names:\n\ndf3.columns = [\"Column 1\", \"Column 2\"]\ndf3\n\n\n\n\n\n\n\n\nColumn 1\nColumn 2\n\n\n\n\nrow 1\n1.0\n4.0\n\n\nrow 2\n2.0\n3.0\n\n\nrow 3\n3.0\n2.0\n\n\nrow 4\n4.0\n1.0\n\n\n\n\n\n\n\nTo print the data type of each column:\n\ndf = pd.DataFrame(\n    {\n        \"A\": np.random.uniform(low=0, high=1, size=12),\n        \"B\": pd.date_range(start=\"20230102\", periods=12),\n        \"C\": pd.Series(range(1, 13), index=[\"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\" ,\"R9\", \"R10\", \"R11\", \"R12\"]),\n        \"D\": np.random.randint(1, high=100, size=12),\n        \"E\": pd.Categorical([\"red\", \"green\", \"blue\", \"white\", \"pink\", \"brown\", \"black\", \"purple\", \"orange\", \"grey\", \"violet\", \"yellow\"]),\n        \"F\": \"foo\",\n    }, index = [\"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\" ,\"R9\", \"R10\", \"R11\", \"R12\"]\n)\nprint(df.dtypes)\n\nA           float64\nB    datetime64[ns]\nC             int64\nD             int64\nE          category\nF            object\ndtype: object"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#reading-and-writing-to-a-file",
    "href": "vignettes/2_Reading_tidying_data.html#reading-and-writing-to-a-file",
    "title": "Reading and Tidying Data",
    "section": "Reading and Writing to a file",
    "text": "Reading and Writing to a file\nUp to this point, all the data we’ve been dealing with has been manually entered into our scripts, and the outcomes of our computations have simply been displayed in the terminal. However, in the real world, data will typically be provided by the users of our programs (which could include you!), and we often need to store the results of our analyses in a more permanent location than just printing them to the screen. During this session, we’ll explore a few commonly used methods for importing data into our programs by reading/writing files from disk using the pandas library.\nIt’s worth noting that there are numerous other ways to access data, such as querying a database or retrieving data from a network, such as the internet. While we won’t cover these methods in this session, Python offers excellent support for interacting with databases and networks, either through its standard library or via external modules.\n\nComma-Seperated Values (CSV) file or Text file\nRead a CSV or text file:\npd.read_csv(\"path_to_file.csv\")\n\n# read a text file with values separated by spaces\npd.read_csv(\"path_to_file.txt\", delimeter=' ')\nWrite a DataFrame df to a CSV or text file:\ndf.to_csv(\"path_to_file.csv\")\ndf.to_csv(\"path_to_file.txt\")\n\n\nExcel file\nRead an excel file:\npd.read_excel(\"path_to_file.xls\", sheet_name=\"Sheet1\")\npd.read_excel(\"path/to/file/name/file_name.csv\")\nWrite a DataFrame df to an excel file:\ndf.to_excel(\"path_to_file.xlsx\", sheet_name=\"Sheet1\")\n\nChallenge\nRead the CSV file associated with the Metabric dataset from this link into a Pandas DataFrame named metabric: “https://zenodo.org/record/6450144/files/metabric_clinical_and_expression_data.csv”.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nimport pandas as pd\n\n# Load the Metabric dataset from the URL into a DataFrame\nmetabric = pd.read_csv(\"https://zenodo.org/record/6450144/files/metabric_clinical_and_expression_data.csv\")"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#viewing-data",
    "href": "vignettes/2_Reading_tidying_data.html#viewing-data",
    "title": "Reading and Tidying Data",
    "section": "Viewing data",
    "text": "Viewing data\nUse DataFrame.head() to view the top rows of the DataFrame. It returns the top 5 rows of the DataFrame.\n\ndf.head()\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\nDataFrame.tail() shows the last 5 rows of the DataFrame.\n\ndf.tail()\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\nDataFrame.index returns the index (row labels) of the DataFrame.\n\ndf.index\n\nIndex(['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8', 'R9', 'R10', 'R11',\n       'R12'],\n      dtype='object')\n\n\nDataFrame.columns returns the column names of the DataFrame.\n\ndf.columns\n\nIndex(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')\n\n\n\nDataFrame.dtypes shows the data type of each column in the DataFrame, allowing you to understand what kind of data each column holds (e.g., integers, floats, or strings).\n\n\ndf.dtypes\n\nA           float64\nB    datetime64[ns]\nC             int64\nD             int64\nE          category\nF            object\ndtype: object\n\n\nTo get the shape of the DataFrame (i.e., the number of rows and columns), use:\n\ndf.shape\n\n(12, 6)\n\n\nTo get the dimensions of the DataFrame (i.e., the number of axes: rows and columns), use:\n\ndf.ndim\n\n2\n\n\nTo get the number of rows in the DataFrame, use:\n\ndf.shape[0]\n\n12\n\n\nTo get the number of columns in the DataFrame, use:\n\ndf.shape[1]\n\n6\n\n\nTo get a NumPy representation of the underlying data without the index or column labels, use:\n\ndf.to_numpy()\n\narray([[0.49136313038754076, Timestamp('2023-01-02 00:00:00'), 1, 64,\n        'red', 'foo'],\n       [0.6544115324820591, Timestamp('2023-01-03 00:00:00'), 2, 96,\n        'green', 'foo'],\n       [0.9481560660996029, Timestamp('2023-01-04 00:00:00'), 3, 25,\n        'blue', 'foo'],\n       [0.7384370666140531, Timestamp('2023-01-05 00:00:00'), 4, 45,\n        'white', 'foo'],\n       [0.6476209993582265, Timestamp('2023-01-06 00:00:00'), 5, 83,\n        'pink', 'foo'],\n       [0.5099028751498758, Timestamp('2023-01-07 00:00:00'), 6, 26,\n        'brown', 'foo'],\n       [0.4013733596442195, Timestamp('2023-01-08 00:00:00'), 7, 67,\n        'black', 'foo'],\n       [0.816294648105314, Timestamp('2023-01-09 00:00:00'), 8, 66,\n        'purple', 'foo'],\n       [0.2522604486299982, Timestamp('2023-01-10 00:00:00'), 9, 11,\n        'orange', 'foo'],\n       [0.6773651695035661, Timestamp('2023-01-11 00:00:00'), 10, 18,\n        'grey', 'foo'],\n       [0.18225858929081862, Timestamp('2023-01-12 00:00:00'), 11, 34,\n        'violet', 'foo'],\n       [0.048109854510631433, Timestamp('2023-01-13 00:00:00'), 12, 74,\n        'yellow', 'foo']], dtype=object)\n\n\nDataFrame.describe() provides a quick statistical summary of the data. This summary includes:\n\ncount: The number of rows for each column.\nmean: The average value for each numerical column.\nstd: The standard deviation, which measures how spread out the values are.\nmin: The minimum value for each column.\npercentiles: Includes the 25th, 50th (median), and 75th percentiles, also known as the 1st, 2nd, and 3rd quartiles.\nmax: The maximum value in each column.\n\n\ndf.describe()\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\ncount\n12.000000\n12\n12.000000\n12.000000\n\n\nmean\n0.530629\n2023-01-07 12:00:00\n6.500000\n50.750000\n\n\nmin\n0.048110\n2023-01-02 00:00:00\n1.000000\n11.000000\n\n\n25%\n0.364095\n2023-01-04 18:00:00\n3.750000\n25.750000\n\n\n50%\n0.578762\n2023-01-07 12:00:00\n6.500000\n54.500000\n\n\n75%\n0.692633\n2023-01-10 06:00:00\n9.250000\n68.750000\n\n\nmax\n0.948156\n2023-01-13 00:00:00\n12.000000\n96.000000\n\n\nstd\n0.269682\nNaN\n3.605551\n27.866973\n\n\n\n\n\n\n\nThe DataFrame.info() method provides a concise summary of the DataFrame’s structure. It is particularly useful for quickly inspecting the basic details of a DataFrame, such as its index, column names, data types, and memory usage.\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 12 entries, R1 to R12\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype         \n---  ------  --------------  -----         \n 0   A       12 non-null     float64       \n 1   B       12 non-null     datetime64[ns]\n 2   C       12 non-null     int64         \n 3   D       12 non-null     int64         \n 4   E       12 non-null     category      \n 5   F       12 non-null     object        \ndtypes: category(1), datetime64[ns](1), float64(1), int64(2), object(1)\nmemory usage: 984.0+ bytes\n\n\nDataFrame.t transpose your data. This results in a DataFrame where the columns of the DataFrame are now rows and the rows are now columns.\n\ndf.T\n\n\n\n\n\n\n\n\nR1\nR2\nR3\nR4\nR5\nR6\nR7\nR8\nR9\nR10\nR11\nR12\n\n\n\n\nA\n0.491363\n0.654412\n0.948156\n0.738437\n0.647621\n0.509903\n0.401373\n0.816295\n0.25226\n0.677365\n0.182259\n0.04811\n\n\nB\n2023-01-02 00:00:00\n2023-01-03 00:00:00\n2023-01-04 00:00:00\n2023-01-05 00:00:00\n2023-01-06 00:00:00\n2023-01-07 00:00:00\n2023-01-08 00:00:00\n2023-01-09 00:00:00\n2023-01-10 00:00:00\n2023-01-11 00:00:00\n2023-01-12 00:00:00\n2023-01-13 00:00:00\n\n\nC\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nD\n64\n96\n25\n45\n83\n26\n67\n66\n11\n18\n34\n74\n\n\nE\nred\ngreen\nblue\nwhite\npink\nbrown\nblack\npurple\norange\ngrey\nviolet\nyellow\n\n\nF\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\nfoo\n\n\n\n\n\n\n\nDataFrame.sort_index() sorts by an axis. If no arguments are provided to this function, it restore to default value where axis = 0 (same as axis = 'index') (rows).axis = 1 (same as axis = 'columns') argument sort based on columns. This sorts the column labels rather than values in the table. This function accepts another argument called ascending which takes a boolean value (True or False).\n\ndf.sort_index(axis=1, ascending=False)\n\n\n\n\n\n\n\n\nF\nE\nD\nC\nB\nA\n\n\n\n\nR1\nfoo\nred\n64\n1\n2023-01-02\n0.491363\n\n\nR2\nfoo\ngreen\n96\n2\n2023-01-03\n0.654412\n\n\nR3\nfoo\nblue\n25\n3\n2023-01-04\n0.948156\n\n\nR4\nfoo\nwhite\n45\n4\n2023-01-05\n0.738437\n\n\nR5\nfoo\npink\n83\n5\n2023-01-06\n0.647621\n\n\nR6\nfoo\nbrown\n26\n6\n2023-01-07\n0.509903\n\n\nR7\nfoo\nblack\n67\n7\n2023-01-08\n0.401373\n\n\nR8\nfoo\npurple\n66\n8\n2023-01-09\n0.816295\n\n\nR9\nfoo\norange\n11\n9\n2023-01-10\n0.252260\n\n\nR10\nfoo\ngrey\n18\n10\n2023-01-11\n0.677365\n\n\nR11\nfoo\nviolet\n34\n11\n2023-01-12\n0.182259\n\n\nR12\nfoo\nyellow\n74\n12\n2023-01-13\n0.048110\n\n\n\n\n\n\n\nDataFrame.sort_values() sorts based on columns. The by argument takes a name or list of column names to sort the DataFrame.\n\ndf.sort_values(by=\"E\")\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nChallenge\n\nPrint the top 5 and the bottom 5 rows of the metabric dataset.\nProvide a high-level overview of the content and then display the content of the metabric dataset.\nWhat is the number of rows and columns in the dataset?\nSort the dataset based on the age_at_diagnosis column.\nSort the dataset based on the Survival_time column.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Print the top 5 rows of the `metabric` dataset\nmetabric.head()\n\n# Print the bottom 5 rows of the `metabric` dataset\nmetabric.tail()\n\n# high-level overview of the content\nmetabric.info()\nmetabric.describe()\n\n# Print the no. of rows (records) and columns (features) in the `metabric` dataset\nmetabric.shape\n# print number of rows only\ndf.shape[0]\n# print number of columns only\ndf.shape[1]\n\n# Sort based on the `age_at_diagnosis` column\ndf.sort_values(\"age_at_diagnosis)\n\n# Sort based on the `Survival_time` column\ndf.sort_values(\"Survival_time)"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#selecting-data",
    "href": "vignettes/2_Reading_tidying_data.html#selecting-data",
    "title": "Reading and Tidying Data",
    "section": "Selecting data",
    "text": "Selecting data\n\nSelecting based on labels\nDataFrame.loc() is used to retrieve a group of rows and/or columns by labels in the DataFrame.\n\nSelecting a row:\n\n\ndf.loc[\"R5\"]\n\nA               0.647621\nB    2023-01-06 00:00:00\nC                      5\nD                     83\nE                   pink\nF                    foo\nName: R5, dtype: object\n\n\n\nSelecting a range of rows:\n\n\ndf.loc[[\"R1\", \"R2\", \"R5\"]]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\ndf.loc[\"R2\":\"R4\"]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\n\n\n\n\n\n\nSelecting a column:\n\n\ndf.loc[:, \"E\"]\n\nR1        red\nR2      green\nR3       blue\nR4      white\nR5       pink\nR6      brown\nR7      black\nR8     purple\nR9     orange\nR10      grey\nR11    violet\nR12    yellow\nName: E, dtype: category\nCategories (12, object): ['black', 'blue', 'brown', 'green', ..., 'red', 'violet', 'white', 'yellow']\n\n\n\nSelecting a range of columns:\n\n\ndf.loc[:, [\"A\",\"C\"]]\n\n\n\n\n\n\n\n\nA\nC\n\n\n\n\nR1\n0.491363\n1\n\n\nR2\n0.654412\n2\n\n\nR3\n0.948156\n3\n\n\nR4\n0.738437\n4\n\n\nR5\n0.647621\n5\n\n\nR6\n0.509903\n6\n\n\nR7\n0.401373\n7\n\n\nR8\n0.816295\n8\n\n\nR9\n0.252260\n9\n\n\nR10\n0.677365\n10\n\n\nR11\n0.182259\n11\n\n\nR12\n0.048110\n12\n\n\n\n\n\n\n\n\ndf.loc[:, \"D\":\"F\"]\n\n\n\n\n\n\n\n\nD\nE\nF\n\n\n\n\nR1\n64\nred\nfoo\n\n\nR2\n96\ngreen\nfoo\n\n\nR3\n25\nblue\nfoo\n\n\nR4\n45\nwhite\nfoo\n\n\nR5\n83\npink\nfoo\n\n\nR6\n26\nbrown\nfoo\n\n\nR7\n67\nblack\nfoo\n\n\nR8\n66\npurple\nfoo\n\n\nR9\n11\norange\nfoo\n\n\nR10\n18\ngrey\nfoo\n\n\nR11\n34\nviolet\nfoo\n\n\nR12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelecting a row and a column:\n\n\ndf.loc[\"R5\", \"A\"]\n\n0.6476209993582265\n\n\n\nSelecting a range of rows and columns:\n\n\ndf.loc[\"R3\":\"R5\", \"D\":\"F\"]\n\n\n\n\n\n\n\n\nD\nE\nF\n\n\n\n\nR3\n25\nblue\nfoo\n\n\nR4\n45\nwhite\nfoo\n\n\nR5\n83\npink\nfoo\n\n\n\n\n\n\n\n\ndf.loc[[\"R3\",\"R2\"], [\"B\",\"D\",\"F\"]]\n\n\n\n\n\n\n\n\nB\nD\nF\n\n\n\n\nR3\n2023-01-04\n25\nfoo\n\n\nR2\n2023-01-03\n96\nfoo\n\n\n\n\n\n\n\n\nSelecting a scalar using DataFrame.at() function:\n\n\ndf.at[\"R1\", \"A\"]\n\n0.49136313038754076\n\n\n\n\nSelecting based on integer positions\nDataFrame.iloc() is used to retrieve a group of rows and/or columns by integer position in the DataFrame. Note: integer position range from 0 to length-1 of rows or columns.\n\nSelecting a row:\n\n\ndf.iloc[4]\n\nA               0.647621\nB    2023-01-06 00:00:00\nC                      5\nD                     83\nE                   pink\nF                    foo\nName: R5, dtype: object\n\n\n\nSelecting a range of rows:\n\n\ndf.iloc[[0, 1, 4]]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\ndf.iloc[2:6]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\n\n\n\n\n\nSelect top 3 rows\n\ndf.iloc[:3]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\n\n\n\n\n\nSelect all rows in the ascending order\n\ndf.iloc[::-1]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\n\n\n\n\n\n\nSelecting a column:\n\n\ndf.iloc[:, 4]\n\nR1        red\nR2      green\nR3       blue\nR4      white\nR5       pink\nR6      brown\nR7      black\nR8     purple\nR9     orange\nR10      grey\nR11    violet\nR12    yellow\nName: E, dtype: category\nCategories (12, object): ['black', 'blue', 'brown', 'green', ..., 'red', 'violet', 'white', 'yellow']\n\n\n\nSelecting a range of columns:\n\n\ndf.iloc[:, [0, 2]]\n\n\n\n\n\n\n\n\nA\nC\n\n\n\n\nR1\n0.491363\n1\n\n\nR2\n0.654412\n2\n\n\nR3\n0.948156\n3\n\n\nR4\n0.738437\n4\n\n\nR5\n0.647621\n5\n\n\nR6\n0.509903\n6\n\n\nR7\n0.401373\n7\n\n\nR8\n0.816295\n8\n\n\nR9\n0.252260\n9\n\n\nR10\n0.677365\n10\n\n\nR11\n0.182259\n11\n\n\nR12\n0.048110\n12\n\n\n\n\n\n\n\n\ndf.iloc[:, 2:5]\n\n\n\n\n\n\n\n\nC\nD\nE\n\n\n\n\nR1\n1\n64\nred\n\n\nR2\n2\n96\ngreen\n\n\nR3\n3\n25\nblue\n\n\nR4\n4\n45\nwhite\n\n\nR5\n5\n83\npink\n\n\nR6\n6\n26\nbrown\n\n\nR7\n7\n67\nblack\n\n\nR8\n8\n66\npurple\n\n\nR9\n9\n11\norange\n\n\nR10\n10\n18\ngrey\n\n\nR11\n11\n34\nviolet\n\n\nR12\n12\n74\nyellow\n\n\n\n\n\n\n\n\nSelecting a row and a column:\n\n\ndf.iloc[4, 0]\n\n0.6476209993582265\n\n\n\nSelecting a range of rows and columns:\n\n\ndf.iloc[2:5, 3:6]\n\n\n\n\n\n\n\n\nD\nE\nF\n\n\n\n\nR3\n25\nblue\nfoo\n\n\nR4\n45\nwhite\nfoo\n\n\nR5\n83\npink\nfoo\n\n\n\n\n\n\n\n\ndf.iloc[[1,3,5], [2,4]]\n\n\n\n\n\n\n\n\nC\nE\n\n\n\n\nR2\n2\ngreen\n\n\nR4\n4\nwhite\n\n\nR6\n6\nbrown\n\n\n\n\n\n\n\n\nSelecting a scalar using DataFrame.iat() function:\n\n\ndf.iat[0, 1]\n\nTimestamp('2023-01-02 00:00:00')\n\n\n\n\nSubset Variables - columns\n\nYou can pass a list of columns to [] to select columns in that order.\n\nSelect a single column by name\n\n\ndf[\"E\"]\n\nR1        red\nR2      green\nR3       blue\nR4      white\nR5       pink\nR6      brown\nR7      black\nR8     purple\nR9     orange\nR10      grey\nR11    violet\nR12    yellow\nName: E, dtype: category\nCategories (12, object): ['black', 'blue', 'brown', 'green', ..., 'red', 'violet', 'white', 'yellow']\n\n\n\ndf.E\n\nR1        red\nR2      green\nR3       blue\nR4      white\nR5       pink\nR6      brown\nR7      black\nR8     purple\nR9     orange\nR10      grey\nR11    violet\nR12    yellow\nName: E, dtype: category\nCategories (12, object): ['black', 'blue', 'brown', 'green', ..., 'red', 'violet', 'white', 'yellow']\n\n\n\nSelect a range of columns with specific names\n\n\ndf[[\"A\",\"C\"]]\n\n\n\n\n\n\n\n\nA\nC\n\n\n\n\nR1\n0.491363\n1\n\n\nR2\n0.654412\n2\n\n\nR3\n0.948156\n3\n\n\nR4\n0.738437\n4\n\n\nR5\n0.647621\n5\n\n\nR6\n0.509903\n6\n\n\nR7\n0.401373\n7\n\n\nR8\n0.816295\n8\n\n\nR9\n0.252260\n9\n\n\nR10\n0.677365\n10\n\n\nR11\n0.182259\n11\n\n\nR12\n0.048110\n12\n\n\n\n\n\n\n\n\nTo subset a DataFrame while excluding specific columns\n\n\ndf.drop(columns=[\"A\",\"B\"])\n\n\n\n\n\n\n\n\nC\nD\nE\nF\n\n\n\n\nR1\n1\n64\nred\nfoo\n\n\nR2\n2\n96\ngreen\nfoo\n\n\nR3\n3\n25\nblue\nfoo\n\n\nR4\n4\n45\nwhite\nfoo\n\n\nR5\n5\n83\npink\nfoo\n\n\nR6\n6\n26\nbrown\nfoo\n\n\nR7\n7\n67\nblack\nfoo\n\n\nR8\n8\n66\npurple\nfoo\n\n\nR9\n9\n11\norange\nfoo\n\n\nR10\n10\n18\ngrey\nfoo\n\n\nR11\n11\n34\nviolet\nfoo\n\n\nR12\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\ndf.drop([\"C\",\"E\", \"F\"], axis=1)\n\n\n\n\n\n\n\n\nA\nB\nD\n\n\n\n\nR1\n0.491363\n2023-01-02\n64\n\n\nR2\n0.654412\n2023-01-03\n96\n\n\nR3\n0.948156\n2023-01-04\n25\n\n\nR4\n0.738437\n2023-01-05\n45\n\n\nR5\n0.647621\n2023-01-06\n83\n\n\nR6\n0.509903\n2023-01-07\n26\n\n\nR7\n0.401373\n2023-01-08\n67\n\n\nR8\n0.816295\n2023-01-09\n66\n\n\nR9\n0.252260\n2023-01-10\n11\n\n\nR10\n0.677365\n2023-01-11\n18\n\n\nR11\n0.182259\n2023-01-12\n34\n\n\nR12\n0.048110\n2023-01-13\n74\n\n\n\n\n\n\n\n\n\nSubset Observations - rows\n\nWith DataFrame, slicing inside of [] slices the rows. This is provided largely as a convenience since it is such a common operation.\n\nSelect the first row\n\n\ndf[:1]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\n\n\n\n\n\n\nSelect the first five row\n\n\ndf[:5]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\nSelect a range of rows\n\n\ndf[3:6]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\n\n\n\n\n\n\nSelect the last row\n\n\ndf[-1:]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR12\n0.04811\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelect the last three row\n\n\ndf[-3:]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelect a range of rows\n\n\ndf[-5:-2]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\n\n\n\n\n\n\nSelect all rows in the ascending order\n\n\ndf[::-1]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\n\n\n\n\n\n\nSubset by condition\nExtract rows that meet a logical criteria.\n\nSelect rows where values in column C is greater than 6\n\n\nabove_6 = df[\"C\"] &gt; 6 # expression over the dataframe that returns a boolean vector \nprint(above_6)\ndf[above_6]\n\nR1     False\nR2     False\nR3     False\nR4     False\nR5     False\nR6     False\nR7      True\nR8      True\nR9      True\nR10     True\nR11     True\nR12     True\nName: C, dtype: bool\n\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelect rows where values in column D is less than or equal to 50\n\n\ndf[df[\"D\"]&lt;= 50]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\n\n\n\n\n\n\ndf[df.D &lt;= 50]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\n\n\n\n\n\n\nUsing isin() function for filtering:\n\n\n# select the rows with values orange and yellow\ndf[df[\"E\"].isin([\"yellow\", \"orange\"])]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR9\n0.25226\n2023-01-10\n9\n11\norange\nfoo\n\n\nR12\n0.04811\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelect rows with Column E is equal to pink or blue\n\n\ndf[df.E.isin([\"pink\", \"blue\"])]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\nRemove duplicate rows (only considers columns).\n\n\n# Add a duplicate row (e.g., duplicating row \"R5\") to df\ndf = pd.concat([df, df.loc[[\"R5\"]]])\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\ndf = df.drop_duplicates()\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nRandomly select n rows.\n\n\ndf.sample(n=10) \n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\nRandomly select fraction of rows.\n\n\ndf.sample(frac=0.5)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\n\n\n\n\n\n\nSelect and order top n entries.\n\n\ndf.nlargest(3, 'D')\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nSelect and order bottom n entries.\n\n\ndf.nsmallest(5, 'A')\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\n\n\n\n\n\n\nTo subset a DataFrame while excluding specific rows\n\n\ndf.drop(index=[\"R1\",\"R2\",\"R3\"])\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\ndf.drop([\"R2\",\"R4\",\"R6\",\"R8\"], axis=0)\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\n\n\nfilter Function\nThe filter() function is used to subset rows or columns based on labels, such as column names or index labels. It is not used for filtering based on the actual values within the DataFrame but rather for subsetting by selecting specific rows or columns.\nDataFrame.filter(items=None, like=None, regex=None, axis=None)\n\nitems: List of labels to filter based on.\nlike: Substring used to filter column or row names containing the provided string.\nregex: Regular expression to filter column or row names.\naxis: Specifies whether to filter on columns (axis=1) or rows (axis=0).\n\nLoad the cms_hospital_patient_satisfaction.csv file from the data folder into a DataFrame named cms, which will be used for the following examples.\n\ncms = pd.read_csv('data/patient_satisfaction/cms_hospital_patient_satisfaction.csv')\n\n\nFilter by Specific Column Names: Select columns “Facility Name” and “Overall Rating”.\n\n\ncms.filter(items=['Facility Name', 'Overall Rating'], axis=1)\n\n\n\n\n\n\n\n\nFacility Name\nOverall Rating\n\n\n\n\n0\nSCRIPPS GREEN HOSPITAL\n5\n\n\n1\nST BERNARD HOSPITAL\n2\n\n\n2\nSOUTH LAKE HOSPITAL\n2\n\n\n3\nMERCY HOSPITAL FORT SMITH\n3\n\n\n4\nBAPTIST MEMORIAL HOSPITAL\n2\n\n\n5\nST JOSEPH REGIONAL HEALTH CENTER\n3\n\n\n6\nGREENE COUNTY GENERAL HOSPITAL\n3\n\n\n7\nSOUTHWEST MEMORIAL HOSPITAL\n3\n\n\n8\nSENTARA GENERAL HOSPITAL\n3\n\n\n9\nPIEDMONT FAYETTE HOSPITAL\n2\n\n\n10\nMISSION COMMUNITY HOSPITAL\n3\n\n\n11\nDOCTORS HOSPITAL\n3\n\n\n12\nSUMNER REGIONAL MEDICAL CENTER\n2\n\n\n13\nWHIDBEY GENERAL HOSPITAL\n3\n\n\n14\nNORTHRIDGE MEDICAL CENTER\n2\n\n\n\n\n\n\n\n\nFilter by Row Index Labels: Select rows with index labels 1,3, 5.\n\n\ncms.filter(items=[1,3,5], axis=0)\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n1\n140103\nST BERNARD HOSPITAL\nCOOK\nAcute Care Hospital\n1\n264\n6\n2\n\n\n3\n40062\nMERCY HOSPITAL FORT SMITH\nSEBASTIAN\nAcute Care Hospital\n3\n2506\n35\n3\n\n\n5\n450011\nST JOSEPH REGIONAL HEALTH CENTER\nBRAZOS\nAcute Care Hospital\n3\n1379\n24\n3\n\n\n\n\n\n\n\n\nFilter Columns by Substring: Select columns whose names contain the substring \"Rating\".\n\n\ncms.filter(like=\"Rating\", axis=1)\n\n\n\n\n\n\n\n\nStar Rating\nOverall Rating\n\n\n\n\n0\n4\n5\n\n\n1\n1\n2\n\n\n2\n2\n2\n\n\n3\n3\n3\n\n\n4\n2\n2\n\n\n5\n3\n3\n\n\n6\n3\n3\n\n\n7\n4\n3\n\n\n8\n4\n3\n\n\n9\n2\n2\n\n\n10\n3\n3\n\n\n11\n4\n3\n\n\n12\n4\n2\n\n\n13\n3\n3\n\n\n14\n3\n2\n\n\n\n\n\n\n\n\nFilter Columns by Regular Expression: Select columns whose names start with the letter \"N\".\n\n\ncms.filter(regex=\"^N\", axis=1)\n\n\n\n\n\n\n\n\nNo of Surveys\n\n\n\n\n0\n3110\n\n\n1\n264\n\n\n2\n1382\n\n\n3\n2506\n\n\n4\n1799\n\n\n5\n1379\n\n\n6\n114\n\n\n7\n247\n\n\n8\n619\n\n\n9\n1714\n\n\n10\n241\n\n\n11\n393\n\n\n12\n680\n\n\n13\n389\n\n\n14\n1110\n\n\n\n\n\n\n\n\nFilter Rows by Regular Expression: Select rows whose index has two digits.\n\n\ncms.filter(regex=\"\\d{2}\", axis=0)\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n10\n50704\nMISSION COMMUNITY HOSPITAL\nLOS ANGELES\nAcute Care Hospital\n3\n241\n14\n3\n\n\n11\n100296\nDOCTORS HOSPITAL\nMIAMI-DADE\nAcute Care Hospital\n4\n393\n24\n3\n\n\n12\n440003\nSUMNER REGIONAL MEDICAL CENTER\nSUMNER\nAcute Care Hospital\n4\n680\n35\n2\n\n\n13\n501339\nWHIDBEY GENERAL HOSPITAL\nISLAND\nCritical Access Hospital\n3\n389\n29\n3\n\n\n14\n50116\nNORTHRIDGE MEDICAL CENTER\nLOS ANGELES\nAcute Care Hospital\n3\n1110\n20\n2\n\n\n\n\n\n\n\n\n\nquery() Function\nThe query() function allows you to filter rows based on specific conditions applied to the values within the DataFrame. It enables writing SQL-like queries on a DataFrame using column names as variables.\nDataFrame.query(expr, inplace=False, **kwargs)\n\nexpr: A string expression used for filtering.\ninplace: Whether to perform the operation in place.\nkwargs: Additional arguments (e.g., to pass column names with spaces).\n\n\nExamples of query():\n\nFilter Rows Based on a Condition: Select rows where the value in column \"Overall Rating\" is greater than 2.\n\n\ncms.query(\"`Overall Rating` &gt; 2\")\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n0\n50424\nSCRIPPS GREEN HOSPITAL\nSAN DIEGO\nAcute Care Hospital\n4\n3110\n41\n5\n\n\n3\n40062\nMERCY HOSPITAL FORT SMITH\nSEBASTIAN\nAcute Care Hospital\n3\n2506\n35\n3\n\n\n5\n450011\nST JOSEPH REGIONAL HEALTH CENTER\nBRAZOS\nAcute Care Hospital\n3\n1379\n24\n3\n\n\n6\n151317\nGREENE COUNTY GENERAL HOSPITAL\nGREENE\nCritical Access Hospital\n3\n114\n22\n3\n\n\n7\n61327\nSOUTHWEST MEMORIAL HOSPITAL\nMONTEZUMA\nCritical Access Hospital\n4\n247\n34\n3\n\n\n8\n490057\nSENTARA GENERAL HOSPITAL\nVIRGINIA BEACH\nAcute Care Hospital\n4\n619\n32\n3\n\n\n10\n50704\nMISSION COMMUNITY HOSPITAL\nLOS ANGELES\nAcute Care Hospital\n3\n241\n14\n3\n\n\n11\n100296\nDOCTORS HOSPITAL\nMIAMI-DADE\nAcute Care Hospital\n4\n393\n24\n3\n\n\n13\n501339\nWHIDBEY GENERAL HOSPITAL\nISLAND\nCritical Access Hospital\n3\n389\n29\n3\n\n\n\n\n\n\n\n\nFilter Rows Based on Multiple Conditions: Select rows where \"Overall Rating\" is greater than 2 and the \"Response Rate\" is less than 30.\n\n\ncms.query(\"`Overall Rating` &gt; 2 and `Response Rate` &lt; 30\")\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n5\n450011\nST JOSEPH REGIONAL HEALTH CENTER\nBRAZOS\nAcute Care Hospital\n3\n1379\n24\n3\n\n\n6\n151317\nGREENE COUNTY GENERAL HOSPITAL\nGREENE\nCritical Access Hospital\n3\n114\n22\n3\n\n\n10\n50704\nMISSION COMMUNITY HOSPITAL\nLOS ANGELES\nAcute Care Hospital\n3\n241\n14\n3\n\n\n11\n100296\nDOCTORS HOSPITAL\nMIAMI-DADE\nAcute Care Hospital\n4\n393\n24\n3\n\n\n13\n501339\nWHIDBEY GENERAL HOSPITAL\nISLAND\nCritical Access Hospital\n3\n389\n29\n3\n\n\n\n\n\n\n\n\nFilter Using a String Condition: Select rows where \"County\" is equal to \"LOS ANGELES\".\n\n\ncms.query(\"County == 'LOS ANGELES'\")\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n10\n50704\nMISSION COMMUNITY HOSPITAL\nLOS ANGELES\nAcute Care Hospital\n3\n241\n14\n3\n\n\n14\n50116\nNORTHRIDGE MEDICAL CENTER\nLOS ANGELES\nAcute Care Hospital\n3\n1110\n20\n2\n\n\n\n\n\n\n\n\nFilter Rows Using or Condition: Select rows where \"Star Rating\" or \"Overall Rating”` is greater than 3.\n\n\ncms.query(\"`Star Rating` &gt; 3 or `Overall Rating` &gt; 3\")\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n0\n50424\nSCRIPPS GREEN HOSPITAL\nSAN DIEGO\nAcute Care Hospital\n4\n3110\n41\n5\n\n\n7\n61327\nSOUTHWEST MEMORIAL HOSPITAL\nMONTEZUMA\nCritical Access Hospital\n4\n247\n34\n3\n\n\n8\n490057\nSENTARA GENERAL HOSPITAL\nVIRGINIA BEACH\nAcute Care Hospital\n4\n619\n32\n3\n\n\n11\n100296\nDOCTORS HOSPITAL\nMIAMI-DADE\nAcute Care Hospital\n4\n393\n24\n3\n\n\n12\n440003\nSUMNER REGIONAL MEDICAL CENTER\nSUMNER\nAcute Care Hospital\n4\n680\n35\n2\n\n\n\n\n\n\n\n\nUse Variable Inside query(): Use a variable to filter rows dynamically.\n\n\nthreshold = 25\ncms.query(\"`Response Rate` &gt; @threshold\")\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n0\n50424\nSCRIPPS GREEN HOSPITAL\nSAN DIEGO\nAcute Care Hospital\n4\n3110\n41\n5\n\n\n3\n40062\nMERCY HOSPITAL FORT SMITH\nSEBASTIAN\nAcute Care Hospital\n3\n2506\n35\n3\n\n\n7\n61327\nSOUTHWEST MEMORIAL HOSPITAL\nMONTEZUMA\nCritical Access Hospital\n4\n247\n34\n3\n\n\n8\n490057\nSENTARA GENERAL HOSPITAL\nVIRGINIA BEACH\nAcute Care Hospital\n4\n619\n32\n3\n\n\n12\n440003\nSUMNER REGIONAL MEDICAL CENTER\nSUMNER\nAcute Care Hospital\n4\n680\n35\n2\n\n\n13\n501339\nWHIDBEY GENERAL HOSPITAL\nISLAND\nCritical Access Hospital\n3\n389\n29\n3\n\n\n\n\n\n\n\n\nFilter Rows Based on Index: Filter based on the index:\n\n\ncms.query('index == 5')\n\n\n\n\n\n\n\n\nID\nFacility Name\nCounty\nHospital Type\nStar Rating\nNo of Surveys\nResponse Rate\nOverall Rating\n\n\n\n\n5\n450011\nST JOSEPH REGIONAL HEALTH CENTER\nBRAZOS\nAcute Care Hospital\n3\n1379\n24\n3"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#setting-data",
    "href": "vignettes/2_Reading_tidying_data.html#setting-data",
    "title": "Reading and Tidying Data",
    "section": "Setting data",
    "text": "Setting data\nOnce a subset of data is filtered using any of the above methods the assignment operator can be used to assign different data. A few examples is shown below.\nConsider the following DataFrame for the examples listed below,\n\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n0.491363\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\n\nUpdate a single cell in the DataFrame:\n\n\ndf.at[\"R1\", \"A\"] = 1.0\ndf.head()\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n1.000000\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\n\n\n\n\n\n\nUpdate multiple cells in the DataFrame:\n\n\n#df_sub[\"E\"] = df[\"red\", \"green\"]\n#df_sub\n\nThe above command shows a warning which says that we are trying to set (or update) values of a copy of a DataFrame rather than the original DataFrame. Recall that df_sub[\"E\"] = df[df[\"E\"].isin([\"yellow\", \"orange\"])], that means we are trying to update yellow and orange in the DataFrame to red and green. However, since we are updating a copy of the DataFrame, row R9 and R12 of the DataFrame df is not still updated as shown below.\n\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n1.000000\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\norange\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\nyellow\nfoo\n\n\n\n\n\n\n\nIf we want to updae the original DataFrame, we should set as follows.\n\ndf.loc[df[\"E\"].isin([\"yellow\", \"orange\"]), \"E\"] = [\"red\", \"green\"]\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n1.000000\n2023-01-02\n1\n64\nred\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\nred\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\ngreen\nfoo\n\n\n\n\n\n\n\n\nAnother useful function within this library is the replace() function which find a value(s) on a DataFrame and replace it with another value on all columns and rows.\n\n\ndf.replace('red', 'blue')\n\n\n\n\n\n\n\n\nA\nB\nC\nD\nE\nF\n\n\n\n\nR1\n1.000000\n2023-01-02\n1\n64\nblue\nfoo\n\n\nR2\n0.654412\n2023-01-03\n2\n96\ngreen\nfoo\n\n\nR3\n0.948156\n2023-01-04\n3\n25\nblue\nfoo\n\n\nR4\n0.738437\n2023-01-05\n4\n45\nwhite\nfoo\n\n\nR5\n0.647621\n2023-01-06\n5\n83\npink\nfoo\n\n\nR6\n0.509903\n2023-01-07\n6\n26\nbrown\nfoo\n\n\nR7\n0.401373\n2023-01-08\n7\n67\nblack\nfoo\n\n\nR8\n0.816295\n2023-01-09\n8\n66\npurple\nfoo\n\n\nR9\n0.252260\n2023-01-10\n9\n11\nblue\nfoo\n\n\nR10\n0.677365\n2023-01-11\n10\n18\ngrey\nfoo\n\n\nR11\n0.182259\n2023-01-12\n11\n34\nviolet\nfoo\n\n\nR12\n0.048110\n2023-01-13\n12\n74\ngreen\nfoo"
  }
]